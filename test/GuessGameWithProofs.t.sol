// SPDX-License-Identifier: MIT
pragma solidity ^0.8.30;

import "forge-std/Test.sol";
import "../src/GuessGame.sol";
import "../src/generated/GuessVerifier.sol";

contract GuessGameWithProofsTest is Test {
    Groth16Verifier public verifier;
    GuessGame public game;

    address creator;
    address guesser;
    address guesser2;

    // Test data with VALID ZK proofs generated by the actual circuit
    // For number=42, salt=123
    bytes32 constant COMMITMENT_42_123 = 0x1d869fb8246b6131377493aaaf1cc16a8284d4aedcb7277079df35d0d1d552d1;

    // Valid proof for correct guess (42)
    uint256[2] validProofACorrect = [
        449531149912136475770353363361707418564909687680427115646129927332134531208,
        14407370880265595278678350402832836798818885365896905083843433929267668266626
    ];
    uint256[2][2] validProofBCorrect = [
        [
            17312921197632836956585949276008014848208220036975940402101347538989464726893,
            14649255969675641484092917911181181213459734554739828453996711367430887656035
        ],
        [
            19731250186663773803803693244597055364914729377868353692576144118343135911407,
            17184617509137607503905361228458251326217701668871035762567589018625184554749
        ]
    ];
    uint256[2] validProofCCorrect = [
        21835658683758097992725297997527117386568439008454908069273763801277098932784,
        9971757975327911076401779803594069722995141305793117329654742372844894117060
    ];
    uint256[4] validPubSignalsCorrect = [
        uint256(13354932457729771147254927911602504548850183657014898888488396374653942452945),
        1, // isCorrect = true
        42, // guess
        100 // maxNumber
    ];

    // Valid proof for incorrect guess (50)
    uint256[2] validProofAIncorrect = [
        10852066913978342118218498818335408844066258321902599194444720468359168576214,
        6965698820638077395094099877008034652702640564558429698785929019854255895452
    ];
    uint256[2][2] validProofBIncorrect = [
        [
            1613230777238805011830229517807176666334104047967446217283376846766348057999,
            4374229236798730817553670335020809672579377927876284581397418664965153211023
        ],
        [
            4520893247875616557226868523444705263309850113066582487089193591474052220970,
            7766575812497568221119740140062493894108981945203859417355220016465955717634
        ]
    ];
    uint256[2] validProofCIncorrect = [
        4156351497089605839121606963169954792875252974032590314960492405100124400333,
        6066764750676488417561440637467884321186918175528620457428676808171983539025
    ];
    uint256[4] validPubSignalsIncorrect = [
        uint256(13354932457729771147254927911602504548850183657014898888488396374653942452945),
        0, // isCorrect = false
        50, // guess
        100 // maxNumber
    ];

    uint256[2] validProofAIncorrect99 = [
        20238257380398462109625305257681209587390634376397924434662156745750380175772,
        20137222033729095677023640340890441018247927495941043856688125858305739190008
    ];
    uint256[2][2] validProofBIncorrect99 = [
        [
            18216358821465894938073906789193441816367439384630773527255415179172982080906,
            5956667654854502273772496828776497077218738640205310299743644974908932105454
        ],
        [
            20554576871044193222203737715797360746377347990010674378385310048234949855070,
            8854741162951976330308983361193467677555820844654082290325622067664808428365
        ]
    ];
    uint256[2] validProofCIncorrect99 = [
        19161772029134157736177401438648405879578080000870552814923080173708876110607,
        16974494634316757488520087426789911676139205226757527939650041947089531989115
    ];
    uint256[4] validPubSignalsIncorrect99 = [
        uint256(13354932457729771147254927911602504548850183657014898888488396374653942452945),
        0, // isCorrect = false
        99, // guess
        100 // maxNumber
    ];

    // ============ Proofs for maxNumber=1000 ============
    // For number=42, salt=123, maxNumber=1000
    uint256[2] validProofACorrect1000 = [
        18847985216665142978081774218178107209768582294586703058667298716424013372379,
        9366440468644165713379979381227061738553224267553713945998292420773558181670
    ];
    uint256[2][2] validProofBCorrect1000 = [
        [
            10072807236965322499995463031915907552715282387944599615263088762260416482150,
            792989414040019749524888096303195844187226625410003610803561269819236391622
        ],
        [
            11148670015275684213916526144672990030417517565958608124887074597305628580014,
            8906201543348422535719486407485301863219203174530813902224940283417457319670
        ]
    ];
    uint256[2] validProofCCorrect1000 = [
        17721477278375672568665059292600073171948001096912167357572928597712931358903,
        12564177556938113320554397360219532740458970332405378746397960050426970324194
    ];
    uint256[4] validPubSignalsCorrect1000 = [
        uint256(13354932457729771147254927911602504548850183657014898888488396374653942452945),
        1, // isCorrect = true
        42, // guess
        1000 // maxNumber
    ];

    uint256[2] validProofAIncorrect1000 = [
        2787075765217130779120796346272195950752009440013549006582882506079121480544,
        4170882576874699946487474481507329871010855828850559551778176221303676763907
    ];
    uint256[2][2] validProofBIncorrect1000 = [
        [
            15637369754087166259453484668084469411240453088299161248309019314790818841577,
            9051254283466963230254045996498904255899790530805492793480413077800312770568
        ],
        [
            16456721088265572335604933803876079280499210966013879915250060954069840475151,
            11935880564889506369974821915935531912849828930775306943116699440033869598251
        ]
    ];
    uint256[2] validProofCIncorrect1000 = [
        19451833340582089559324443608080995885856791775870146011846347807192349166803,
        12670556175182414222220330734118591452010589161431528389062246032635357458678
    ];
    uint256[4] validPubSignalsIncorrect1000 = [
        uint256(13354932457729771147254927911602504548850183657014898888488396374653942452945),
        0, // isCorrect = false
        50, // guess
        1000 // maxNumber
    ];

    // ============ Proofs for maxNumber=65535 (full 16-bit range) ============
    // For number=50000, salt=999, maxNumber=65535
    bytes32 constant COMMITMENT_50000_999 = 0x2cc18bc721abaa61b337c7223c0e0cfc2a80edfa8f5ba0a39b8c01285c78504a;

    uint256[2] validProofACorrect65535 = [
        10598737190753346751574744581419436545095237921406774980412613779518807527848,
        6426529550030088879839628654264983608203547148595051753929428140487144388859
    ];
    uint256[2][2] validProofBCorrect65535 = [
        [
            3486639708413223218370050557604656066356042530302616042926175876252588232134,
            1434939216509495009292800081090199847308768092825159112399066050848573139769
        ],
        [
            4840481135868384718516775991348095134491587540684076483249190596779173265346,
            10204110299085893118125113153704096388051065873532927683454255988921757351894
        ]
    ];
    uint256[2] validProofCCorrect65535 = [
        21291174315797348261043953694775560695185631114833029062499063660597799546789,
        19696660917708073713109439871998029249355357778354827827198147489183306556770
    ];
    uint256[4] validPubSignalsCorrect65535 = [
        uint256(20243731532483464653008282803235725156917772166930941746636225099857223241802),
        1, // isCorrect = true
        50000, // guess
        65535 // maxNumber
    ];

    uint256[2] validProofAIncorrect65535 = [
        4783117061383643717978727120617543697060671113850020198738562741012154887279,
        17072574070951115007123801855231149624184649949369314930111493037180535066555
    ];
    uint256[2][2] validProofBIncorrect65535 = [
        [
            6593447033291639939399615175040692675367233183888056461502896136905606121062,
            14396528473537351017523760101610528354507779308424497731228307514922984932404
        ],
        [
            3978460844663001671471038227866805695716918410099357276397627677400969384129,
            8699465782584489286649220703004908452310658536344237044384748396729714537752
        ]
    ];
    uint256[2] validProofCIncorrect65535 = [
        15243511192750540389584047533282711128331674168668611110707075373636037191200,
        15598490172305429329926265640839405790579106649434256972132723537578154134101
    ];
    uint256[4] validPubSignalsIncorrect65535 = [
        uint256(20243731532483464653008282803235725156917772166930941746636225099857223241802),
        0, // isCorrect = false
        12345, // guess
        65535 // maxNumber
    ];

    address treasury;

    function setUp() public {
        // Create test addresses that can receive ETH
        creator = makeAddr("creator");
        guesser = makeAddr("guesser");
        guesser2 = makeAddr("guesser2");
        treasury = makeAddr("treasury");

        // Deploy verifier first
        verifier = new Groth16Verifier();
        // Deploy game with verifier address and treasury
        game = new GuessGame(address(verifier), treasury);

        vm.deal(creator, 10 ether);
        vm.deal(guesser, 10 ether);
        vm.deal(guesser2, 10 ether);
    }

    function test_RespondToChallenge_CorrectGuess_WithValidProof() public {
        // Create puzzle
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0.01 ether, 100);

        // Submit correct guess
        vm.prank(guesser);
        uint256 challengeId = game.submitGuess{value: 0.01 ether}(puzzleId, 42);

        // Check initial state
        IGuessGame.Puzzle memory puzzleBefore = game.getPuzzle(puzzleId);
        assertEq(puzzleBefore.pendingChallenges, 1);
        assertEq(puzzleBefore.solved, false);

        uint256 guesserBalanceBefore = guesser.balance;

        // Respond with valid proof showing guess is correct
        vm.prank(creator);
        game.respondToChallenge(
            puzzleId, challengeId, validProofACorrect, validProofBCorrect, validProofCCorrect, validPubSignalsCorrect
        );

        // Verify puzzle is solved
        IGuessGame.Puzzle memory puzzleAfter = game.getPuzzle(puzzleId);
        assertEq(puzzleAfter.solved, true);
        assertEq(puzzleAfter.pendingChallenges, 0);

        // Verify challenge is marked as responded
        IGuessGame.Challenge memory challenge = game.getChallenge(puzzleId, challengeId);
        assertEq(challenge.responded, true);

        // Verify winner received bounty + stake
        uint256 expectedPrize = 0.1 ether + 0.01 ether; // bounty + stake
        assertEq(guesser.balance, guesserBalanceBefore + expectedPrize);
    }

    function test_RespondToChallenge_IncorrectGuess_WithValidProof() public {
        // Create puzzle
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0.01 ether, 100);

        // Submit incorrect guess
        vm.prank(guesser);
        uint256 challengeId = game.submitGuess{value: 0.01 ether}(puzzleId, 50);

        uint256 guesserBalanceBefore = guesser.balance;

        // Respond with valid proof showing guess is incorrect
        vm.prank(creator);
        game.respondToChallenge(
            puzzleId,
            challengeId,
            validProofAIncorrect,
            validProofBIncorrect,
            validProofCIncorrect,
            validPubSignalsIncorrect
        );

        // Verify puzzle is NOT solved
        IGuessGame.Puzzle memory puzzleAfter = game.getPuzzle(puzzleId);
        assertEq(puzzleAfter.solved, false);
        assertEq(puzzleAfter.pendingChallenges, 0);

        // Verify guesser got their stake back (simplified economics)
        assertEq(guesser.balance, guesserBalanceBefore + 0.01 ether);
    }

    function test_RespondToChallenge_MultipleGuesses_ThenCorrect() public {
        // Create puzzle
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0.01 ether, 100);

        // First incorrect guess
        vm.prank(guesser);
        uint256 challengeId1 = game.submitGuess{value: 0.01 ether}(puzzleId, 50);

        uint256 guesser1BalanceBefore = guesser.balance;

        // Respond to first guess (incorrect) - guesser gets stake back
        vm.prank(creator);
        game.respondToChallenge(
            puzzleId,
            challengeId1,
            validProofAIncorrect,
            validProofBIncorrect,
            validProofCIncorrect,
            validPubSignalsIncorrect
        );

        // Guesser should have stake back
        assertEq(guesser.balance, guesser1BalanceBefore + 0.01 ether);

        // Second incorrect guess from different guesser
        vm.prank(guesser2);
        uint256 challengeId2 = game.submitGuess{value: 0.01 ether}(puzzleId, 99);

        uint256 guesser2BalanceBefore = guesser2.balance;

        // Respond with proof for guess 99
        vm.prank(creator);
        game.respondToChallenge(
            puzzleId,
            challengeId2,
            validProofAIncorrect99,
            validProofBIncorrect99,
            validProofCIncorrect99,
            validPubSignalsIncorrect99
        );

        // Guesser2 should have stake back
        assertEq(guesser2.balance, guesser2BalanceBefore + 0.01 ether);

        IGuessGame.Puzzle memory puzzleAfterIncorrect = game.getPuzzle(puzzleId);
        assertEq(puzzleAfterIncorrect.bounty, 0.1 ether); // Bounty unchanged
        assertEq(puzzleAfterIncorrect.pendingChallenges, 0);

        // Now submit correct guess
        uint256 guesserBalanceBefore = guesser.balance;
        vm.prank(guesser);
        uint256 challengeId3 = game.submitGuess{value: 0.01 ether}(puzzleId, 42);

        // Respond with correct proof
        vm.prank(creator);
        game.respondToChallenge(
            puzzleId, challengeId3, validProofACorrect, validProofBCorrect, validProofCCorrect, validPubSignalsCorrect
        );

        // Verify puzzle is solved
        IGuessGame.Puzzle memory puzzleFinal = game.getPuzzle(puzzleId);
        assertEq(puzzleFinal.solved, true);

        // Winner gets bounty + stake back
        uint256 expectedWinnerPrize = 0.1 ether + 0.01 ether;
        assertEq(guesser.balance, guesserBalanceBefore - 0.01 ether + expectedWinnerPrize);
    }

    function test_RespondToChallenge_AnyOrder() public {
        // Create puzzle
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0.01 ether, 100);

        // Submit multiple guesses
        vm.prank(guesser);
        uint256 challengeId1 = game.submitGuess{value: 0.01 ether}(puzzleId, 50);

        vm.prank(guesser2);
        uint256 challengeId2 = game.submitGuess{value: 0.01 ether}(puzzleId, 99);

        // Respond out of order - challenge 2 first (should work with no queue enforcement)
        // Must use correct proof for guess 99
        vm.prank(creator);
        game.respondToChallenge(
            puzzleId,
            challengeId2,
            validProofAIncorrect99,
            validProofBIncorrect99,
            validProofCIncorrect99,
            validPubSignalsIncorrect99
        );

        // Then respond to challenge 1 with proof for guess 50
        vm.prank(creator);
        game.respondToChallenge(
            puzzleId,
            challengeId1,
            validProofAIncorrect,
            validProofBIncorrect,
            validProofCIncorrect,
            validPubSignalsIncorrect
        );

        // Both challenges responded
        IGuessGame.Challenge memory c1 = game.getChallenge(puzzleId, challengeId1);
        IGuessGame.Challenge memory c2 = game.getChallenge(puzzleId, challengeId2);
        assertEq(c1.responded, true);
        assertEq(c2.responded, true);
    }

    function test_RespondToChallenge_InvalidCommitment_Reverts() public {
        // Create puzzle
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0.01 ether, 100);

        vm.prank(guesser);
        uint256 challengeId = game.submitGuess{value: 0.01 ether}(puzzleId, 42);

        // Create proof with wrong commitment
        uint256[4] memory wrongPubSignals = [
            uint256(0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef), // wrong commitment
            1,
            42,
            100 // maxNumber
        ];

        vm.prank(creator);
        vm.expectRevert(IGuessGame.InvalidProof.selector);
        game.respondToChallenge(
            puzzleId, challengeId, validProofACorrect, validProofBCorrect, validProofCCorrect, wrongPubSignals
        );
    }

    function test_RespondToChallenge_InvalidProofForChallengeGuess() public {
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0.01 ether, 100);

        // Guesser submits guess 11
        vm.prank(guesser);
        uint256 challengeId = game.submitGuess{value: 0.01 ether}(puzzleId, 11);

        // Guesser submits guess 42
        vm.prank(guesser);
        uint256 challengeId1 = game.submitGuess{value: 0.01 ether}(puzzleId, 42);

        // Try to respond to challenge for guess 11 with proof for guess 42 - should fail
        vm.prank(creator);
        vm.expectRevert(IGuessGame.InvalidProofForChallengeGuess.selector);
        game.respondToChallenge(
            puzzleId, challengeId, validProofACorrect, validProofBCorrect, validProofCCorrect, validPubSignalsCorrect
        );

        // Try to respond to challenge for guess 42 with proof for guess 99 - should fail
        vm.prank(creator);
        vm.expectRevert(IGuessGame.InvalidProofForChallengeGuess.selector);
        game.respondToChallenge(
            puzzleId,
            challengeId1,
            validProofAIncorrect99,
            validProofBIncorrect99,
            validProofCIncorrect99,
            validPubSignalsIncorrect99
        );
    }

    function test_RespondToChallenge_AlreadyResponded_Reverts() public {
        // Create puzzle and submit guess
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0.01 ether, 100);

        vm.prank(guesser);
        uint256 challengeId = game.submitGuess{value: 0.01 ether}(puzzleId, 50);

        // First response
        vm.prank(creator);
        game.respondToChallenge(
            puzzleId,
            challengeId,
            validProofAIncorrect,
            validProofBIncorrect,
            validProofCIncorrect,
            validPubSignalsIncorrect
        );

        // Try to respond again
        vm.prank(creator);
        vm.expectRevert(IGuessGame.ChallengeAlreadyResponded.selector);
        game.respondToChallenge(
            puzzleId,
            challengeId,
            validProofAIncorrect,
            validProofBIncorrect,
            validProofCIncorrect,
            validPubSignalsIncorrect
        );
    }

    function test_RespondToChallenge_PuzzleAlreadySolved_Reverts() public {
        // Create puzzle
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0.01 ether, 100);

        // First guess (correct)
        vm.prank(guesser);
        uint256 challengeId1 = game.submitGuess{value: 0.01 ether}(puzzleId, 42);

        // Second guess
        vm.prank(guesser2);
        uint256 challengeId2 = game.submitGuess{value: 0.01 ether}(puzzleId, 50);

        // Solve puzzle with first guess
        vm.prank(creator);
        game.respondToChallenge(
            puzzleId, challengeId1, validProofACorrect, validProofBCorrect, validProofCCorrect, validPubSignalsCorrect
        );

        // Try to respond to second guess after puzzle is solved
        vm.prank(creator);
        vm.expectRevert(IGuessGame.PuzzleAlreadySolved.selector);
        game.respondToChallenge(
            puzzleId,
            challengeId2,
            validProofAIncorrect,
            validProofBIncorrect,
            validProofCIncorrect,
            validPubSignalsIncorrect
        );
    }

    function test_CancelPuzzle_AfterAllResponsesProcessed() public {
        // Create puzzle
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0.01 ether, 100);

        // Submit guess
        vm.prank(guesser);
        uint256 challengeId = game.submitGuess{value: 0.01 ether}(puzzleId, 50);

        // Can't cancel with pending challenges
        vm.prank(creator);
        vm.expectRevert(IGuessGame.HasPendingChallenges.selector);
        game.cancelPuzzle(puzzleId);

        // Respond to challenge (guesser gets stake back)
        vm.prank(creator);
        game.respondToChallenge(
            puzzleId,
            challengeId,
            validProofAIncorrect,
            validProofBIncorrect,
            validProofCIncorrect,
            validPubSignalsIncorrect
        );

        // Can't cancel yet - timeout hasn't passed
        vm.prank(creator);
        vm.expectRevert(IGuessGame.CancelTooSoon.selector);
        game.cancelPuzzle(puzzleId);

        // Warp time past the timeout
        vm.warp(block.timestamp + game.CANCEL_TIMEOUT() + 1);

        uint256 creatorBalanceBefore = creator.balance;

        // Now can cancel after timeout
        vm.prank(creator);
        game.cancelPuzzle(puzzleId);

        // Creator gets bounty + collateral back
        assertEq(creator.balance, creatorBalanceBefore + 0.2 ether);

        IGuessGame.Puzzle memory puzzle = game.getPuzzle(puzzleId);
        assertEq(puzzle.cancelled, true);
    }

    // ============ Forfeit Tests with Proofs ============

    function test_RespondToChallenge_PuzzleForfeited_Reverts() public {
        // Create puzzle
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0.01 ether, 100);

        // Submit guess
        vm.prank(guesser);
        uint256 challengeId = game.submitGuess{value: 0.01 ether}(puzzleId, 50);

        // Warp time and forfeit
        vm.warp(block.timestamp + game.RESPONSE_TIMEOUT() + 1);
        game.forfeitPuzzle(puzzleId, challengeId);

        // Try to respond after forfeit - should fail
        vm.prank(creator);
        vm.expectRevert(IGuessGame.PuzzleForfeitedError.selector);
        game.respondToChallenge(
            puzzleId,
            challengeId,
            validProofAIncorrect,
            validProofBIncorrect,
            validProofCIncorrect,
            validPubSignalsIncorrect
        );
    }

    function test_ForfeitPuzzle_ChallengeAlreadyResponded_Reverts() public {
        // Create puzzle
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0.01 ether, 100);

        // Submit two guesses
        vm.prank(guesser);
        uint256 challengeId1 = game.submitGuess{value: 0.01 ether}(puzzleId, 50);

        vm.prank(guesser2);
        uint256 challengeId2 = game.submitGuess{value: 0.01 ether}(puzzleId, 99);

        // Respond to challenge 1
        vm.prank(creator);
        game.respondToChallenge(
            puzzleId,
            challengeId1,
            validProofAIncorrect,
            validProofBIncorrect,
            validProofCIncorrect,
            validPubSignalsIncorrect
        );

        // Warp time
        vm.warp(block.timestamp + game.RESPONSE_TIMEOUT() + 1);

        // Try to forfeit using the responded challenge - should fail
        vm.expectRevert(IGuessGame.ChallengeAlreadyResponded.selector);
        game.forfeitPuzzle(puzzleId, challengeId1);

        // But can forfeit using challenge 2 (which was not responded)
        game.forfeitPuzzle(puzzleId, challengeId2);

        IGuessGame.Puzzle memory puzzle = game.getPuzzle(puzzleId);
        assertEq(puzzle.forfeited, true);
        assertEq(puzzle.pendingAtForfeit, 1); // Only challengeId2 was pending
    }

    function test_ForfeitAndClaim_AfterPartialResponses() public {
        // Create puzzle with 0.12 ether bounty (0.24 total = 0.12 bounty + 0.12 collateral, divisible by 2)
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.24 ether}(COMMITMENT_42_123, 0.01 ether, 100);

        // Submit three guesses
        vm.prank(guesser);
        uint256 challengeId1 = game.submitGuess{value: 0.01 ether}(puzzleId, 50);

        vm.prank(guesser2);
        uint256 challengeId2 = game.submitGuess{value: 0.01 ether}(puzzleId, 99);

        address guesser3 = makeAddr("guesser3");
        vm.deal(guesser3, 10 ether);
        vm.prank(guesser3);
        uint256 challengeId3 = game.submitGuess{value: 0.01 ether}(puzzleId, 77);

        // Creator responds to challenge 1 only (guesser gets stake back)
        vm.prank(creator);
        game.respondToChallenge(
            puzzleId,
            challengeId1,
            validProofAIncorrect,
            validProofBIncorrect,
            validProofCIncorrect,
            validPubSignalsIncorrect
        );

        // Warp time past timeout
        vm.warp(block.timestamp + game.RESPONSE_TIMEOUT() + 1);

        // Forfeit using challenge 2
        game.forfeitPuzzle(puzzleId, challengeId2);

        IGuessGame.Puzzle memory puzzle = game.getPuzzle(puzzleId);
        assertEq(puzzle.forfeited, true);
        assertEq(puzzle.pendingAtForfeit, 2); // challenges 2 and 3 were pending

        // Both pending guessers claim (single call per guesser)
        vm.prank(guesser2);
        game.claimFromForfeited(puzzleId);

        vm.prank(guesser3);
        game.claimFromForfeited(puzzleId);

        // Each gets stake (0.01) + bounty share (0.12 / 2 = 0.06)
        assertEq(game.balances(guesser2), 0.01 ether + 0.06 ether);
        assertEq(game.balances(guesser3), 0.01 ether + 0.06 ether);

        // Withdraw
        uint256 guesser2BalanceBefore = guesser2.balance;
        uint256 guesser3BalanceBefore = guesser3.balance;

        vm.prank(guesser2);
        game.withdraw();
        vm.prank(guesser3);
        game.withdraw();

        assertEq(guesser2.balance, guesser2BalanceBefore + 0.07 ether);
        assertEq(guesser3.balance, guesser3BalanceBefore + 0.07 ether);

        // guesser (who was responded to) has no pending challenges to claim
        vm.prank(guesser);
        vm.expectRevert(IGuessGame.NothingToClaim.selector);
        game.claimFromForfeited(puzzleId);
    }

    // ============ Multi-Operation Scenario Test ============

    /**
     * @notice Complete game flow test:
     * 1. Creator creates a puzzle
     * 2. 2 guessers submit wrong guesses
     * 3. Creator tries to submit proofs for wrong guess numbers and fails
     * 4. Creator submits proper proofs (guessers get stakes back)
     * 5. 3rd guesser submits the right answer
     * 6. Creator responds and guesser wins bounty + stake
     */
    function test_CompleteGameFlow_WrongProofsThenCorrectWin() public {
        // Track balances
        uint256 creatorStartBalance = creator.balance;
        uint256 guesser1StartBalance = guesser.balance;
        uint256 guesser2StartBalance = guesser2.balance;

        // ========== Step 1: Creator creates puzzle ==========
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0.01 ether, 100);

        assertEq(creator.balance, creatorStartBalance - 0.2 ether);

        IGuessGame.Puzzle memory puzzle = game.getPuzzle(puzzleId);
        assertEq(puzzle.creator, creator);
        assertEq(puzzle.bounty, 0.1 ether);
        assertEq(puzzle.collateral, 0.1 ether);
        assertEq(puzzle.solved, false);

        // ========== Step 2: 2 guessers submit wrong guesses ==========
        // Guesser 1 guesses 50 (wrong)
        vm.prank(guesser);
        uint256 challengeId1 = game.submitGuess{value: 0.01 ether}(puzzleId, 50);
        assertEq(guesser.balance, guesser1StartBalance - 0.01 ether);

        // Guesser 2 guesses 99 (wrong)
        vm.prank(guesser2);
        uint256 challengeId2 = game.submitGuess{value: 0.01 ether}(puzzleId, 99);
        assertEq(guesser2.balance, guesser2StartBalance - 0.01 ether);

        puzzle = game.getPuzzle(puzzleId);
        assertEq(puzzle.pendingChallenges, 2);
        assertEq(puzzle.challengeCount, 2);

        // ========== Step 3: Creator tries wrong proofs and fails ==========
        // Try to respond to challenge for guess 50 with proof for guess 99
        vm.prank(creator);
        vm.expectRevert(IGuessGame.InvalidProofForChallengeGuess.selector);
        game.respondToChallenge(
            puzzleId,
            challengeId1, // challenge for guess 50
            validProofAIncorrect99,
            validProofBIncorrect99,
            validProofCIncorrect99,
            validPubSignalsIncorrect99 // proof for guess 99
        );

        // Try to respond to challenge for guess 99 with proof for guess 50
        vm.prank(creator);
        vm.expectRevert(IGuessGame.InvalidProofForChallengeGuess.selector);
        game.respondToChallenge(
            puzzleId,
            challengeId2, // challenge for guess 99
            validProofAIncorrect,
            validProofBIncorrect,
            validProofCIncorrect,
            validPubSignalsIncorrect // proof for guess 50
        );

        // Try to respond to wrong guess with correct proof (proof says correct but guess wasn't 42)
        vm.prank(creator);
        vm.expectRevert(IGuessGame.InvalidProofForChallengeGuess.selector);
        game.respondToChallenge(
            puzzleId,
            challengeId1, // challenge for guess 50
            validProofACorrect,
            validProofBCorrect,
            validProofCCorrect,
            validPubSignalsCorrect // proof for guess 42 (correct answer)
        );

        // Challenges should still be pending
        puzzle = game.getPuzzle(puzzleId);
        assertEq(puzzle.pendingChallenges, 2);

        // ========== Step 4: Creator submits proper proofs ==========
        // Respond to guess 50 with proof for guess 50
        vm.prank(creator);
        game.respondToChallenge(
            puzzleId,
            challengeId1,
            validProofAIncorrect,
            validProofBIncorrect,
            validProofCIncorrect,
            validPubSignalsIncorrect
        );

        // Guesser 1 should have stake back
        assertEq(guesser.balance, guesser1StartBalance);

        // Respond to guess 99 with proof for guess 99
        vm.prank(creator);
        game.respondToChallenge(
            puzzleId,
            challengeId2,
            validProofAIncorrect99,
            validProofBIncorrect99,
            validProofCIncorrect99,
            validPubSignalsIncorrect99
        );

        // Guesser 2 should have stake back
        assertEq(guesser2.balance, guesser2StartBalance);

        // Puzzle should still be unsolved with no pending challenges
        puzzle = game.getPuzzle(puzzleId);
        assertEq(puzzle.solved, false);
        assertEq(puzzle.pendingChallenges, 0);
        assertEq(puzzle.bounty, 0.1 ether); // Bounty intact

        // ========== Step 5: 3rd guesser submits the right answer ==========
        address guesser3 = makeAddr("guesser3");
        vm.deal(guesser3, 10 ether);
        uint256 guesser3StartBalance = guesser3.balance;

        vm.prank(guesser3);
        uint256 challengeId3 = game.submitGuess{value: 0.01 ether}(puzzleId, 42);

        assertEq(guesser3.balance, guesser3StartBalance - 0.01 ether);

        puzzle = game.getPuzzle(puzzleId);
        assertEq(puzzle.pendingChallenges, 1);
        assertEq(puzzle.challengeCount, 3);

        // ========== Step 6: Creator responds, guesser wins bounty + stake ==========
        vm.prank(creator);
        game.respondToChallenge(
            puzzleId, challengeId3, validProofACorrect, validProofBCorrect, validProofCCorrect, validPubSignalsCorrect
        );

        // Verify final state
        puzzle = game.getPuzzle(puzzleId);
        assertEq(puzzle.solved, true);
        assertEq(puzzle.pendingChallenges, 0);

        // Winner (guesser3) gets bounty + stake
        uint256 expectedWinnerPrize = 0.1 ether + 0.01 ether;
        assertEq(guesser3.balance, guesser3StartBalance - 0.01 ether + expectedWinnerPrize);
        assertEq(guesser3.balance, guesser3StartBalance + 0.1 ether); // Net gain = bounty

        // Creator's ETH balance is down 0.2 ether (initial payment), but collateral credited to internal balance
        assertEq(creator.balance, creatorStartBalance - 0.2 ether);
        assertEq(game.balances(creator), 0.1 ether); // Collateral returned

        // Guesser 1 and 2 are back to original balances (stakes returned)
        assertEq(guesser.balance, guesser1StartBalance);
        assertEq(guesser2.balance, guesser2StartBalance);

        // Verify challenges are marked as responded
        IGuessGame.Challenge memory c1 = game.getChallenge(puzzleId, challengeId1);
        IGuessGame.Challenge memory c2 = game.getChallenge(puzzleId, challengeId2);
        IGuessGame.Challenge memory c3 = game.getChallenge(puzzleId, challengeId3);
        assertEq(c1.responded, true);
        assertEq(c2.responded, true);
        assertEq(c3.responded, true);
    }

    /**
     * @notice Test that creator can respond to challenges in any order
     * Challenges submitted: 1, 2 (with guesses 50, 99)
     * Responses given: 2, 1 (reverse order)
     * Note: Limited to 2 challenges because we only have valid proofs for guesses 50 and 99
     */
    function test_ResponsesInAnyOrder() public {
        // Create puzzle
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0.01 ether, 100);

        // Submit 2 guesses in order (we only have proofs for 50 and 99)
        vm.prank(guesser);
        uint256 challengeId1 = game.submitGuess{value: 0.01 ether}(puzzleId, 50);

        vm.prank(guesser2);
        uint256 challengeId2 = game.submitGuess{value: 0.01 ether}(puzzleId, 99);

        IGuessGame.Puzzle memory puzzle = game.getPuzzle(puzzleId);
        assertEq(puzzle.pendingChallenges, 2);

        // Respond in reverse order: 2, 1 (not submission order)

        // First respond to challenge 2 (guess 99)
        vm.prank(creator);
        game.respondToChallenge(
            puzzleId,
            challengeId2,
            validProofAIncorrect99,
            validProofBIncorrect99,
            validProofCIncorrect99,
            validPubSignalsIncorrect99
        );

        puzzle = game.getPuzzle(puzzleId);
        assertEq(puzzle.pendingChallenges, 1);
        assertEq(game.getChallenge(puzzleId, challengeId2).responded, true);
        assertEq(game.getChallenge(puzzleId, challengeId1).responded, false);

        // Then respond to challenge 1 (guess 50)
        vm.prank(creator);
        game.respondToChallenge(
            puzzleId,
            challengeId1,
            validProofAIncorrect,
            validProofBIncorrect,
            validProofCIncorrect,
            validPubSignalsIncorrect
        );

        puzzle = game.getPuzzle(puzzleId);
        assertEq(puzzle.pendingChallenges, 0);
        assertEq(game.getChallenge(puzzleId, challengeId1).responded, true);

        // All responded, puzzle still unsolved
        assertEq(puzzle.solved, false);
    }

    /**
     * @notice Test that after forfeit, guessers can claim in any order
     * Guessers: 1, 2, 3, 4
     * Claims made: 4, 2, 1, 3 (random order)
     */
    function test_ForfeitClaimsInAnyOrder() public {
        // Create puzzle with bounty divisible by 4
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0.01 ether, 100);

        // Create 4 guessers and submit guesses
        address guesser3 = makeAddr("guesser3");
        address guesser4 = makeAddr("guesser4");
        vm.deal(guesser3, 10 ether);
        vm.deal(guesser4, 10 ether);

        uint256 guesser1Start = guesser.balance;
        uint256 guesser2Start = guesser2.balance;
        uint256 guesser3Start = guesser3.balance;
        uint256 guesser4Start = guesser4.balance;

        vm.prank(guesser);
        game.submitGuess{value: 0.01 ether}(puzzleId, 50);

        vm.prank(guesser2);
        game.submitGuess{value: 0.01 ether}(puzzleId, 99);

        vm.prank(guesser3);
        game.submitGuess{value: 0.01 ether}(puzzleId, 77);

        vm.prank(guesser4);
        game.submitGuess{value: 0.01 ether}(puzzleId, 88);

        IGuessGame.Puzzle memory puzzle = game.getPuzzle(puzzleId);
        assertEq(puzzle.pendingChallenges, 4);

        // Warp time past timeout and forfeit
        vm.warp(block.timestamp + game.RESPONSE_TIMEOUT() + 1);
        game.forfeitPuzzle(puzzleId, 0);

        puzzle = game.getPuzzle(puzzleId);
        assertEq(puzzle.forfeited, true);
        assertEq(puzzle.pendingAtForfeit, 4);

        // Bounty is 0.1 ether (half of 0.2 ether total)
        // Each guesser should get: stake (0.01) + bounty share (0.1 / 4 = 0.025)
        uint256 expectedPayout = 0.01 ether + 0.025 ether;

        // Claim in order: 4, 2, 1, 3 (not submission order) - single call per guesser
        vm.prank(guesser4);
        game.claimFromForfeited(puzzleId);
        assertEq(game.balances(guesser4), expectedPayout);

        vm.prank(guesser2);
        game.claimFromForfeited(puzzleId);
        assertEq(game.balances(guesser2), expectedPayout);

        vm.prank(guesser);
        game.claimFromForfeited(puzzleId);
        assertEq(game.balances(guesser), expectedPayout);

        vm.prank(guesser3);
        game.claimFromForfeited(puzzleId);
        assertEq(game.balances(guesser3), expectedPayout);

        // Withdraw all
        vm.prank(guesser4);
        game.withdraw();
        vm.prank(guesser2);
        game.withdraw();
        vm.prank(guesser);
        game.withdraw();
        vm.prank(guesser3);
        game.withdraw();

        // Verify net gains: each guesser gained 0.025 ether (their share of 0.1 ether bounty / 4)
        assertEq(guesser.balance, guesser1Start + 0.025 ether);
        assertEq(guesser2.balance, guesser2Start + 0.025 ether);
        assertEq(guesser3.balance, guesser3Start + 0.025 ether);
        assertEq(guesser4.balance, guesser4Start + 0.025 ether);
    }

    // ============ Protocol Hole Tests (These SHOULD FAIL until fixed) ============

    /**
     * @notice Test that guessers can recover stakes when puzzle is solved with pending challenges
     *
     * Scenario:
     * 1. Guesser A submits correct guess (42)
     * 2. Guesser B submits wrong guess (50)
     * 3. Creator responds to A first â†’ puzzle solved, A wins
     * 4. Guesser B can call claimStakeFromSolved to recover their stake
     */
    function test_ClaimStakeFromSolved() public {
        // Create puzzle
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0.01 ether, 100);

        uint256 guesser1Start = guesser.balance;
        uint256 guesser2Start = guesser2.balance;

        // Guesser 1 submits correct guess (42)
        vm.prank(guesser);
        uint256 challengeId1 = game.submitGuess{value: 0.01 ether}(puzzleId, 42);

        // Guesser 2 submits wrong guess (50)
        vm.prank(guesser2);
        uint256 challengeId2 = game.submitGuess{value: 0.01 ether}(puzzleId, 50);

        // Creator responds to guesser 1 (correct) - puzzle is solved
        vm.prank(creator);
        game.respondToChallenge(
            puzzleId, challengeId1, validProofACorrect, validProofBCorrect, validProofCCorrect, validPubSignalsCorrect
        );

        // Guesser 1 wins bounty + stake
        assertEq(guesser.balance, guesser1Start + 0.1 ether);

        // Puzzle is solved, guesser 2's challenge is still pending
        IGuessGame.Puzzle memory puzzle = game.getPuzzle(puzzleId);
        assertEq(puzzle.solved, true);

        // Guesser 2 claims their stake back (single call)
        vm.prank(guesser2);
        game.claimStakeFromSolved(puzzleId);

        // Balance should be credited
        assertEq(game.balances(guesser2), 0.01 ether);

        // Withdraw
        vm.prank(guesser2);
        game.withdraw();

        // Guesser 2 should have their stake returned
        assertEq(guesser2.balance, guesser2Start, "Guesser 2 should have stake returned");

        // Creator has collateral in internal balance
        assertEq(game.balances(creator), 0.1 ether, "Creator should have collateral in balance");

        // Creator withdraws collateral
        vm.prank(creator);
        game.withdraw();

        // Contract should have no funds left
        assertEq(address(game).balance, 0, "Contract should have no stuck funds");
    }

    /**
     * @notice Test bounty distribution with rounding
     *
     * With per-guesser aggregates, each guesser gets proportional share.
     * Minimal dust (1-2 wei) may remain in contract from integer division.
     */
    function test_BountyDistributionWithRounding() public {
        // Create puzzle with bounty that won't divide evenly by 3
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0.01 ether, 100);

        // Create 3 guessers
        address guesser3 = makeAddr("guesser3");
        vm.deal(guesser3, 10 ether);

        uint256 guesser1Start = guesser.balance;
        uint256 guesser2Start = guesser2.balance;
        uint256 guesser3Start = guesser3.balance;

        // All 3 submit guesses (unique numbers)
        vm.prank(guesser);
        game.submitGuess{value: 0.01 ether}(puzzleId, 50);

        vm.prank(guesser2);
        game.submitGuess{value: 0.01 ether}(puzzleId, 99);

        vm.prank(guesser3);
        game.submitGuess{value: 0.01 ether}(puzzleId, 77);

        // Forfeit the puzzle
        vm.warp(block.timestamp + game.RESPONSE_TIMEOUT() + 1);
        game.forfeitPuzzle(puzzleId, 0);

        // Calculate expected shares
        uint256 bounty = 0.1 ether;
        uint256 bountyShare = bounty / 3; // 33333333333333333 wei

        // All guessers claim (single call each)
        vm.prank(guesser);
        game.claimFromForfeited(puzzleId);

        vm.prank(guesser2);
        game.claimFromForfeited(puzzleId);

        vm.prank(guesser3);
        game.claimFromForfeited(puzzleId);

        // Verify balances credited
        assertEq(game.balances(guesser), 0.01 ether + bountyShare);
        assertEq(game.balances(guesser2), 0.01 ether + bountyShare);
        assertEq(game.balances(guesser3), 0.01 ether + bountyShare);

        // Withdraw all
        vm.prank(guesser);
        game.withdraw();
        vm.prank(guesser2);
        game.withdraw();
        vm.prank(guesser3);
        game.withdraw();

        // Each guesser gained their bounty share
        assertEq(guesser.balance, guesser1Start + bountyShare);
        assertEq(guesser2.balance, guesser2Start + bountyShare);
        assertEq(guesser3.balance, guesser3Start + bountyShare);
    }

    // ============ Protocol Issue Tests ============

    /**
     * @notice Protocol should enforce minimum stake at puzzle creation
     */
    function test_MinimumStakeRequired() public {
        vm.prank(creator);
        vm.expectRevert(IGuessGame.InsufficientStake.selector);
        game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0, 100);
    }

    /**
     * @notice Same guesser can submit multiple challenges (by design)
     *
     * This is acceptable because guessers risk their own funds. The "dilution attack"
     * mentioned in GitHub Issue #10 requires attacker to stake their own funds,
     * and forfeit is a recovery mechanism, not the intended path.
     */
    function test_SameGuesserMultipleChallenges_DesignDecision() public {
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0.01 ether, 100);

        uint256 guesserStart = guesser.balance;

        // Same guesser submits 3 different guesses
        vm.prank(guesser);
        game.submitGuess{value: 0.01 ether}(puzzleId, 50);

        vm.prank(guesser);
        game.submitGuess{value: 0.01 ether}(puzzleId, 99);

        vm.prank(guesser);
        game.submitGuess{value: 0.01 ether}(puzzleId, 77);

        assertEq(guesser.balance, guesserStart - 0.03 ether);

        vm.warp(block.timestamp + game.RESPONSE_TIMEOUT() + 1);
        game.forfeitPuzzle(puzzleId, 0);

        IGuessGame.Puzzle memory puzzle = game.getPuzzle(puzzleId);
        assertEq(puzzle.pendingAtForfeit, 3);

        // Single claim for all challenges
        vm.prank(guesser);
        game.claimFromForfeited(puzzleId);

        // Balance credited: 3 stakes + entire bounty (3/3 share)
        assertEq(game.balances(guesser), 0.03 ether + 0.1 ether);

        // Withdraw
        vm.prank(guesser);
        game.withdraw();

        // Guesser gets stakes back + entire bounty
        assertEq(guesser.balance, guesserStart + 0.1 ether);
    }

    /**
     * @notice Creator cannot guess their own puzzle
     *
     * Related: GitHub Issue #10 - https://github.com/chainhackers/zk-guess-contracts/issues/10
     */
    function test_CreatorCannotSelfGuess() public {
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0.01 ether, 100);

        vm.prank(creator);
        vm.expectRevert(IGuessGame.CreatorCannotGuess.selector);
        game.submitGuess{value: 0.01 ether}(puzzleId, 42);
    }

    /**
     * @notice Two players claim for 3 guesses where one player has 2 guesses
     *
     * Guesser1: 2 challenges (0.01 + 0.02 = 0.03 ether stake)
     * Guesser2: 1 challenge (0.01 ether stake)
     * Bounty: 0.15 ether, split by challenge count (2:1)
     */
    function test_TwoPlayersClaim_OneWithMultipleGuesses() public {
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.3 ether}(COMMITMENT_42_123, 0.01 ether, 100);

        uint256 guesser1Start = guesser.balance;
        uint256 guesser2Start = guesser2.balance;

        // Guesser1 submits 2 guesses
        vm.prank(guesser);
        game.submitGuess{value: 0.01 ether}(puzzleId, 50);

        vm.prank(guesser);
        game.submitGuess{value: 0.02 ether}(puzzleId, 99);

        // Guesser2 submits 1 guess
        vm.prank(guesser2);
        game.submitGuess{value: 0.01 ether}(puzzleId, 77);

        // Forfeit
        vm.warp(block.timestamp + game.RESPONSE_TIMEOUT() + 1);
        game.forfeitPuzzle(puzzleId, 0);

        IGuessGame.Puzzle memory puzzle = game.getPuzzle(puzzleId);
        assertEq(puzzle.pendingAtForfeit, 3);

        // Both claim (single call each)
        vm.prank(guesser);
        game.claimFromForfeited(puzzleId);

        vm.prank(guesser2);
        game.claimFromForfeited(puzzleId);

        // Guesser1: stake (0.03) + bounty share (0.15 * 2/3 = 0.1)
        assertEq(game.balances(guesser), 0.03 ether + 0.1 ether);

        // Guesser2: stake (0.01) + bounty share (0.15 * 1/3 = 0.05)
        assertEq(game.balances(guesser2), 0.01 ether + 0.05 ether);

        // Withdraw
        vm.prank(guesser);
        game.withdraw();
        vm.prank(guesser2);
        game.withdraw();

        // Verify final balances
        assertEq(guesser.balance, guesser1Start + 0.1 ether); // gained bounty share
        assertEq(guesser2.balance, guesser2Start + 0.05 ether); // gained bounty share
    }

    /**
     * @notice Players claim from multiple puzzles and withdraw combined balance
     *
     * Puzzle 1: Forfeited, guesser gets stake + bounty
     * Puzzle 2: Solved by guesser2, guesser gets stake back
     * Both withdraw their accumulated balances in single call
     */
    function test_ClaimFromMultiplePuzzles_ThenWithdraw() public {
        uint256 guesser1Start = guesser.balance;
        uint256 guesser2Start = guesser2.balance;

        // ========== Puzzle 1: Will be forfeited ==========
        vm.prank(creator);
        uint256 puzzleId1 = game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0.01 ether, 100);

        vm.prank(guesser);
        game.submitGuess{value: 0.01 ether}(puzzleId1, 50);

        vm.prank(guesser2);
        game.submitGuess{value: 0.01 ether}(puzzleId1, 99);

        // ========== Puzzle 2: Will be solved by guesser2 ==========
        vm.prank(creator);
        uint256 puzzleId2 = game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0.01 ether, 100);

        vm.prank(guesser);
        game.submitGuess{value: 0.02 ether}(puzzleId2, 50);

        vm.prank(guesser2);
        game.submitGuess{value: 0.02 ether}(puzzleId2, 42); // correct guess

        // ========== Puzzle 1: Forfeit ==========
        vm.warp(block.timestamp + game.RESPONSE_TIMEOUT() + 1);
        game.forfeitPuzzle(puzzleId1, 0);

        // Both claim from puzzle 1
        vm.prank(guesser);
        game.claimFromForfeited(puzzleId1);
        // guesser: 0.01 stake + 0.05 bounty (0.1/2)

        vm.prank(guesser2);
        game.claimFromForfeited(puzzleId1);
        // guesser2: 0.01 stake + 0.05 bounty (0.1/2)

        // ========== Puzzle 2: Solve ==========
        // Reset time for puzzle 2 responses
        vm.warp(block.timestamp - game.RESPONSE_TIMEOUT());

        // Creator responds to guesser's wrong guess
        vm.prank(creator);
        game.respondToChallenge(
            puzzleId2, 0, validProofAIncorrect, validProofBIncorrect, validProofCIncorrect, validPubSignalsIncorrect
        );
        // guesser gets 0.02 stake back immediately

        // Creator responds to guesser2's correct guess - puzzle solved
        vm.prank(creator);
        game.respondToChallenge(
            puzzleId2, 1, validProofACorrect, validProofBCorrect, validProofCCorrect, validPubSignalsCorrect
        );
        // guesser2 gets 0.02 stake + 0.2 bounty immediately

        // ========== Check balances before withdraw ==========
        // Guesser: 0.01 + 0.05 from puzzle 1 forfeit claim
        assertEq(game.balances(guesser), 0.06 ether);

        // Guesser2: 0.01 + 0.05 from puzzle 1 forfeit claim
        assertEq(game.balances(guesser2), 0.06 ether);

        // ========== Withdraw ==========
        vm.prank(guesser);
        game.withdraw();

        vm.prank(guesser2);
        game.withdraw();

        // ========== Verify final balances ==========
        // Bounty is 0.1 ether per puzzle (half of 0.2 ether total)
        // Guesser: started, paid 0.01+0.02=0.03 stakes, got back:
        //   - 0.02 immediately from puzzle2 response
        //   - 0.06 from withdraw (puzzle1 claim: 0.01 stake + 0.05 bounty share)
        // Net: +0.05 (bounty share from puzzle1)
        assertEq(guesser.balance, guesser1Start + 0.05 ether);

        // Guesser2: started, paid 0.01+0.02=0.03 stakes, got back:
        //   - 0.02+0.1=0.12 immediately from puzzle2 win (bounty is 0.1 ether)
        //   - 0.06 from withdraw (puzzle1 claim: 0.01 stake + 0.05 bounty share)
        // Net: +0.05 (puzzle1 share) + 0.1 (puzzle2 bounty) = +0.15
        assertEq(guesser2.balance, guesser2Start + 0.15 ether);
    }

    // ============ Additional Coverage Tests ============

    /**
     * @notice Multiple guessers claim stakes from a solved puzzle
     */
    function test_ClaimStakeFromSolved_MultipleGuessers() public {
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0.01 ether, 100);

        uint256 guesser1Start = guesser.balance;
        uint256 guesser2Start = guesser2.balance;

        address guesser3 = makeAddr("guesser3");
        vm.deal(guesser3, 10 ether);
        uint256 guesser3Start = guesser3.balance;

        // Three guessers submit - guesser3 will win
        vm.prank(guesser);
        game.submitGuess{value: 0.01 ether}(puzzleId, 50);

        vm.prank(guesser2);
        game.submitGuess{value: 0.02 ether}(puzzleId, 99);

        vm.prank(guesser3);
        game.submitGuess{value: 0.01 ether}(puzzleId, 42); // correct

        // Creator responds to guesser3's correct guess first - puzzle solved
        vm.prank(creator);
        game.respondToChallenge(
            puzzleId, 2, validProofACorrect, validProofBCorrect, validProofCCorrect, validPubSignalsCorrect
        );

        // guesser3 wins bounty + stake immediately
        assertEq(guesser3.balance, guesser3Start + 0.1 ether);

        // Other guessers claim their stakes back
        vm.prank(guesser);
        game.claimStakeFromSolved(puzzleId);

        vm.prank(guesser2);
        game.claimStakeFromSolved(puzzleId);

        assertEq(game.balances(guesser), 0.01 ether);
        assertEq(game.balances(guesser2), 0.02 ether);

        // Withdraw
        vm.prank(guesser);
        game.withdraw();
        vm.prank(guesser2);
        game.withdraw();

        assertEq(guesser.balance, guesser1Start);
        assertEq(guesser2.balance, guesser2Start);
    }

    /**
     * @notice Balance accumulates from both forfeit and solved claims
     */
    function test_BalanceAccumulates_MixedClaimTypes() public {
        uint256 guesserStart = guesser.balance;

        // Puzzle 1: Will be forfeited
        vm.prank(creator);
        uint256 puzzleId1 = game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0.01 ether, 100);

        vm.prank(guesser);
        game.submitGuess{value: 0.01 ether}(puzzleId1, 50);

        // Puzzle 2: Will be solved by someone else
        vm.prank(creator);
        uint256 puzzleId2 = game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0.01 ether, 100);

        vm.prank(guesser);
        game.submitGuess{value: 0.02 ether}(puzzleId2, 50);

        vm.prank(guesser2);
        game.submitGuess{value: 0.01 ether}(puzzleId2, 42); // winner

        // Forfeit puzzle 1
        vm.warp(block.timestamp + game.RESPONSE_TIMEOUT() + 1);
        game.forfeitPuzzle(puzzleId1, 0);

        vm.prank(guesser);
        game.claimFromForfeited(puzzleId1);
        // guesser: 0.01 stake + 0.1 bounty = 0.11

        // Solve puzzle 2
        vm.warp(block.timestamp - game.RESPONSE_TIMEOUT());
        vm.prank(creator);
        game.respondToChallenge(
            puzzleId2, 1, validProofACorrect, validProofBCorrect, validProofCCorrect, validPubSignalsCorrect
        );

        // guesser claims stake from solved puzzle
        vm.prank(guesser);
        game.claimStakeFromSolved(puzzleId2);
        // guesser: adds 0.02 stake

        // Combined balance
        assertEq(game.balances(guesser), 0.11 ether + 0.02 ether);

        // Single withdraw gets everything
        vm.prank(guesser);
        game.withdraw();

        // Net: paid 0.03 stakes, got 0.13 back = +0.10 (bounty from puzzle1)
        assertEq(guesser.balance, guesserStart + 0.1 ether);
    }

    /**
     * @notice Withdraw with zero balance reverts
     */
    function test_Withdraw_ZeroBalance() public {
        vm.prank(guesser);
        vm.expectRevert(IGuessGame.NothingToWithdraw.selector);
        game.withdraw();
    }

    /**
     * @notice Second withdraw after first succeeds reverts
     */
    function test_Withdraw_MultipleTimes() public {
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0.01 ether, 100);

        vm.prank(guesser);
        game.submitGuess{value: 0.01 ether}(puzzleId, 50);

        vm.warp(block.timestamp + game.RESPONSE_TIMEOUT() + 1);
        game.forfeitPuzzle(puzzleId, 0);

        vm.prank(guesser);
        game.claimFromForfeited(puzzleId);

        // First withdraw succeeds
        vm.prank(guesser);
        game.withdraw();

        // Second withdraw fails
        vm.prank(guesser);
        vm.expectRevert(IGuessGame.NothingToWithdraw.selector);
        game.withdraw();
    }

    /**
     * @notice Guesser with multiple challenges claims all at once from solved puzzle
     */
    function test_ClaimStakeFromSolved_GuesserWithMultipleChallenges() public {
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0.01 ether, 100);

        uint256 guesserStart = guesser.balance;

        // Guesser submits 3 wrong guesses
        vm.prank(guesser);
        game.submitGuess{value: 0.01 ether}(puzzleId, 50);

        vm.prank(guesser);
        game.submitGuess{value: 0.02 ether}(puzzleId, 99);

        vm.prank(guesser);
        game.submitGuess{value: 0.03 ether}(puzzleId, 77);

        // guesser2 wins
        vm.prank(guesser2);
        game.submitGuess{value: 0.01 ether}(puzzleId, 42);

        vm.prank(creator);
        game.respondToChallenge(
            puzzleId, 3, validProofACorrect, validProofBCorrect, validProofCCorrect, validPubSignalsCorrect
        );

        // Guesser claims all 3 stakes in one call
        vm.prank(guesser);
        game.claimStakeFromSolved(puzzleId);

        assertEq(game.balances(guesser), 0.06 ether); // 0.01 + 0.02 + 0.03

        vm.prank(guesser);
        game.withdraw();

        assertEq(guesser.balance, guesserStart); // got all stakes back
    }

    /**
     * @notice Winner's aggregates are zeroed so they cannot claim
     */
    function test_ClaimStakeFromSolved_WinnerCannotClaim() public {
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0.01 ether, 100);

        vm.prank(guesser);
        game.submitGuess{value: 0.01 ether}(puzzleId, 42); // correct

        vm.prank(creator);
        game.respondToChallenge(
            puzzleId, 0, validProofACorrect, validProofBCorrect, validProofCCorrect, validPubSignalsCorrect
        );

        // Winner's aggregates are decremented to 0
        assertEq(game.guesserStakeTotal(puzzleId, guesser), 0);
        assertEq(game.guesserChallengeCount(puzzleId, guesser), 0);

        // Winner tries to claim - nothing to claim
        vm.prank(guesser);
        vm.expectRevert(IGuessGame.NothingToClaim.selector);
        game.claimStakeFromSolved(puzzleId);
    }

    /**
     * @notice Verify aggregates decrement correctly after respondToChallenge
     */
    function test_AggregatesDecrementOnResponse() public {
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0.01 ether, 100);

        // Guesser submits 2 guesses
        vm.prank(guesser);
        game.submitGuess{value: 0.01 ether}(puzzleId, 50);

        vm.prank(guesser);
        game.submitGuess{value: 0.02 ether}(puzzleId, 99);

        // Check initial aggregates
        assertEq(game.guesserStakeTotal(puzzleId, guesser), 0.03 ether);
        assertEq(game.guesserChallengeCount(puzzleId, guesser), 2);

        // Respond to first challenge
        vm.prank(creator);
        game.respondToChallenge(
            puzzleId, 0, validProofAIncorrect, validProofBIncorrect, validProofCIncorrect, validPubSignalsIncorrect
        );

        // Aggregates decremented
        assertEq(game.guesserStakeTotal(puzzleId, guesser), 0.02 ether);
        assertEq(game.guesserChallengeCount(puzzleId, guesser), 1);

        // Respond to second challenge
        vm.prank(creator);
        game.respondToChallenge(
            puzzleId,
            1,
            validProofAIncorrect99,
            validProofBIncorrect99,
            validProofCIncorrect99,
            validPubSignalsIncorrect99
        );

        // Aggregates now zero
        assertEq(game.guesserStakeTotal(puzzleId, guesser), 0);
        assertEq(game.guesserChallengeCount(puzzleId, guesser), 0);
    }

    /**
     * @notice Cannot claim from unsolved puzzle
     */
    function test_ClaimStakeFromSolved_UnsolvedPuzzle() public {
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0.01 ether, 100);

        vm.prank(guesser);
        game.submitGuess{value: 0.01 ether}(puzzleId, 50);

        vm.prank(guesser);
        vm.expectRevert(IGuessGame.PuzzleNotSolved.selector);
        game.claimStakeFromSolved(puzzleId);
    }

    /**
     * @notice Cannot claim from cancelled puzzle
     */
    function test_ClaimFromCancelledPuzzle() public {
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0.01 ether, 100);

        // Cancel immediately (no challenges)
        vm.prank(creator);
        game.cancelPuzzle(puzzleId);

        // Cannot claim forfeit
        vm.prank(guesser);
        vm.expectRevert(IGuessGame.PuzzleNotForfeited.selector);
        game.claimFromForfeited(puzzleId);

        // Cannot claim solved
        vm.prank(guesser);
        vm.expectRevert(IGuessGame.PuzzleNotSolved.selector);
        game.claimStakeFromSolved(puzzleId);
    }

    /**
     * @notice Balance accumulates from multiple forfeited puzzles
     */
    function test_BalanceAccumulates_MultipleForfeitedPuzzles() public {
        uint256 guesserStart = guesser.balance;

        // Create and forfeit 3 puzzles
        uint256[] memory puzzleIds = new uint256[](3);

        for (uint256 i = 0; i < 3; i++) {
            vm.prank(creator);
            puzzleIds[i] = game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0.01 ether, 100);

            vm.prank(guesser);
            game.submitGuess{value: 0.01 ether}(puzzleIds[i], 50);
        }

        // Forfeit all
        vm.warp(block.timestamp + game.RESPONSE_TIMEOUT() + 1);
        for (uint256 i = 0; i < 3; i++) {
            game.forfeitPuzzle(puzzleIds[i], 0);
        }

        // Claim from all
        for (uint256 i = 0; i < 3; i++) {
            vm.prank(guesser);
            game.claimFromForfeited(puzzleIds[i]);
        }

        // Balance = 3 * (0.01 stake + 0.1 bounty) = 0.33 ether
        assertEq(game.balances(guesser), 0.33 ether);

        // Single withdraw
        vm.prank(guesser);
        game.withdraw();

        // Net gain = 3 * 0.1 bounty = 0.3 ether
        assertEq(guesser.balance, guesserStart + 0.3 ether);
    }

    /**
     * @notice Single guesser on forfeit gets entire bounty
     */
    function test_SingleGuesserForfeit_GetsEntireBounty() public {
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 1 ether}(COMMITMENT_42_123, 0.01 ether, 100);

        uint256 guesserStart = guesser.balance;

        vm.prank(guesser);
        game.submitGuess{value: 0.01 ether}(puzzleId, 50);

        vm.warp(block.timestamp + game.RESPONSE_TIMEOUT() + 1);
        game.forfeitPuzzle(puzzleId, 0);

        vm.prank(guesser);
        game.claimFromForfeited(puzzleId);

        // Gets stake + entire bounty
        assertEq(game.balances(guesser), 0.01 ether + 0.5 ether);

        vm.prank(guesser);
        game.withdraw();

        assertEq(guesser.balance, guesserStart + 0.5 ether);
    }

    /**
     * @notice Forfeit claim works correctly at MIN_STAKE
     */
    function test_MinStake_ForfeitClaim() public {
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0.00001 ether, 100);

        uint256 guesserStart = guesser.balance;

        // Submit at exactly MIN_STAKE
        vm.prank(guesser);
        game.submitGuess{value: 0.00001 ether}(puzzleId, 50);

        vm.warp(block.timestamp + game.RESPONSE_TIMEOUT() + 1);
        game.forfeitPuzzle(puzzleId, 0);

        vm.prank(guesser);
        game.claimFromForfeited(puzzleId);

        // Gets MIN_STAKE + entire bounty
        assertEq(game.balances(guesser), 0.00001 ether + 0.1 ether);

        vm.prank(guesser);
        game.withdraw();

        assertEq(guesser.balance, guesserStart + 0.1 ether);
    }

    // ============ Collateral Tests ============

    /**
     * @notice Verify creator gets collateral back when puzzle is solved (correct guess)
     */
    function test_CorrectGuessReturnsCollateralToCreator() public {
        uint256 creatorStart = creator.balance;

        // Create puzzle with 0.2 ether (0.1 bounty + 0.1 collateral)
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0.01 ether, 100);

        assertEq(creator.balance, creatorStart - 0.2 ether);

        // Submit correct guess
        vm.prank(guesser);
        uint256 challengeId = game.submitGuess{value: 0.01 ether}(puzzleId, 42);

        // Respond with correct proof
        vm.prank(creator);
        game.respondToChallenge(
            puzzleId, challengeId, validProofACorrect, validProofBCorrect, validProofCCorrect, validPubSignalsCorrect
        );

        // Creator's collateral should be credited to internal balance
        assertEq(game.balances(creator), 0.1 ether);

        // Creator withdraws collateral
        vm.prank(creator);
        game.withdraw();

        // Creator now has: original - 0.2 (paid) + 0.1 (collateral) = original - 0.1 (lost bounty only)
        assertEq(creator.balance, creatorStart - 0.1 ether);
    }

    /**
     * @notice Verify duplicate guesses are rejected (basic test with proofs)
     */
    function test_DuplicateGuessRejected() public {
        // Create puzzle
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0.01 ether, 100);

        // First guess succeeds
        vm.prank(guesser);
        game.submitGuess{value: 0.01 ether}(puzzleId, 50);

        // Duplicate guess from different guesser fails
        vm.prank(guesser2);
        vm.expectRevert(IGuessGame.GuessAlreadySubmitted.selector);
        game.submitGuess{value: 0.01 ether}(puzzleId, 50);
    }

    /**
     * @notice Verify collateral is still fully slashed after partial responses
     */
    function test_ForfeitAfterPartialResponses_CollateralStillSlashed() public {
        uint256 treasuryStart = treasury.balance;

        // Create puzzle
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.24 ether}(COMMITMENT_42_123, 0.01 ether, 100);

        // Submit three guesses
        vm.prank(guesser);
        game.submitGuess{value: 0.01 ether}(puzzleId, 50);

        vm.prank(guesser2);
        game.submitGuess{value: 0.01 ether}(puzzleId, 99);

        address guesser3 = makeAddr("guesser3");
        vm.deal(guesser3, 10 ether);
        vm.prank(guesser3);
        game.submitGuess{value: 0.01 ether}(puzzleId, 77);

        // Creator responds to challenge 0 only
        vm.prank(creator);
        game.respondToChallenge(
            puzzleId, 0, validProofAIncorrect, validProofBIncorrect, validProofCIncorrect, validPubSignalsIncorrect
        );

        // Warp and forfeit using challenge 1
        vm.warp(block.timestamp + game.RESPONSE_TIMEOUT() + 1);
        game.forfeitPuzzle(puzzleId, 1);

        // Treasury gets FULL collateral (0.12 ether), not partial
        assertEq(treasury.balance, treasuryStart + 0.12 ether);
    }

    /**
     * @notice All incorrect guesses responded - creator keeps collateral on cancel
     */
    function test_AllIncorrectGuesses_NoSlashing() public {
        uint256 treasuryStart = treasury.balance;

        // Create puzzle
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0.01 ether, 100);

        // Submit 2 wrong guesses
        vm.prank(guesser);
        game.submitGuess{value: 0.01 ether}(puzzleId, 50);

        vm.prank(guesser2);
        game.submitGuess{value: 0.01 ether}(puzzleId, 99);

        // Creator responds to both
        vm.prank(creator);
        game.respondToChallenge(
            puzzleId, 0, validProofAIncorrect, validProofBIncorrect, validProofCIncorrect, validPubSignalsIncorrect
        );

        vm.prank(creator);
        game.respondToChallenge(
            puzzleId,
            1,
            validProofAIncorrect99,
            validProofBIncorrect99,
            validProofCIncorrect99,
            validPubSignalsIncorrect99
        );

        // Warp past cancel timeout and cancel
        vm.warp(block.timestamp + game.CANCEL_TIMEOUT() + 1);

        uint256 creatorBalanceBefore = creator.balance;

        vm.prank(creator);
        game.cancelPuzzle(puzzleId);

        // Creator gets bounty + collateral back
        assertEq(creator.balance, creatorBalanceBefore + 0.2 ether);

        // Treasury unchanged - no slashing
        assertEq(treasury.balance, treasuryStart);
    }

    /**
     * @notice Verify collateral is slashed to treasury on forfeit
     */
    function test_ForfeitSlashesCollateral() public {
        uint256 treasuryStart = treasury.balance;

        // Create puzzle
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0.01 ether, 100);

        // Submit guess
        vm.prank(guesser);
        uint256 challengeId = game.submitGuess{value: 0.01 ether}(puzzleId, 50);

        // Warp and forfeit
        vm.warp(block.timestamp + game.RESPONSE_TIMEOUT() + 1);
        game.forfeitPuzzle(puzzleId, challengeId);

        // Treasury receives collateral
        assertEq(treasury.balance, treasuryStart + 0.1 ether);

        // Guesser can still claim bounty share
        vm.prank(guesser);
        game.claimFromForfeited(puzzleId);
        assertEq(game.balances(guesser), 0.01 ether + 0.1 ether); // stake + entire bounty
    }

    // ============ Tests for maxNumber > 100 ============

    /**
     * @notice Test puzzle with maxNumber=1000 - correct guess
     */
    function test_MaxNumber1000_CorrectGuess() public {
        // Create puzzle with maxNumber=1000
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0.01 ether, 1000);

        // Verify maxNumber stored correctly
        IGuessGame.Puzzle memory puzzle = game.getPuzzle(puzzleId);
        assertEq(puzzle.maxNumber, 1000);

        // Submit correct guess
        vm.prank(guesser);
        uint256 challengeId = game.submitGuess{value: 0.01 ether}(puzzleId, 42);

        uint256 guesserBalanceBefore = guesser.balance;

        // Respond with valid proof for maxNumber=1000
        vm.prank(creator);
        game.respondToChallenge(
            puzzleId,
            challengeId,
            validProofACorrect1000,
            validProofBCorrect1000,
            validProofCCorrect1000,
            validPubSignalsCorrect1000
        );

        // Verify puzzle is solved
        assertTrue(game.getPuzzle(puzzleId).solved);

        // Winner gets bounty + stake
        uint256 expectedPrize = 0.1 ether + 0.01 ether;
        assertEq(guesser.balance, guesserBalanceBefore + expectedPrize);
    }

    /**
     * @notice Test puzzle with maxNumber=1000 - incorrect guess
     */
    function test_MaxNumber1000_IncorrectGuess() public {
        // Create puzzle with maxNumber=1000
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0.01 ether, 1000);

        // Submit incorrect guess
        vm.prank(guesser);
        uint256 challengeId = game.submitGuess{value: 0.01 ether}(puzzleId, 50);

        uint256 guesserBalanceBefore = guesser.balance;

        // Respond with valid proof for incorrect guess
        vm.prank(creator);
        game.respondToChallenge(
            puzzleId,
            challengeId,
            validProofAIncorrect1000,
            validProofBIncorrect1000,
            validProofCIncorrect1000,
            validPubSignalsIncorrect1000
        );

        // Puzzle not solved
        assertFalse(game.getPuzzle(puzzleId).solved);

        // Guesser gets stake back
        assertEq(guesser.balance, guesserBalanceBefore + 0.01 ether);
    }

    /**
     * @notice Test puzzle with maxNumber=65535 (full 16-bit range) - large secret number
     */
    function test_MaxNumber65535_LargeSecret_CorrectGuess() public {
        // Create puzzle with maxNumber=65535 and large secret (50000)
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.2 ether}(COMMITMENT_50000_999, 0.01 ether, 65535);

        // Verify maxNumber stored correctly
        IGuessGame.Puzzle memory puzzle = game.getPuzzle(puzzleId);
        assertEq(puzzle.maxNumber, 65535);

        // Submit correct guess (50000)
        vm.prank(guesser);
        uint256 challengeId = game.submitGuess{value: 0.01 ether}(puzzleId, 50000);

        uint256 guesserBalanceBefore = guesser.balance;

        // Respond with valid proof for maxNumber=65535
        vm.prank(creator);
        game.respondToChallenge(
            puzzleId,
            challengeId,
            validProofACorrect65535,
            validProofBCorrect65535,
            validProofCCorrect65535,
            validPubSignalsCorrect65535
        );

        // Verify puzzle is solved
        assertTrue(game.getPuzzle(puzzleId).solved);

        // Winner gets bounty + stake
        uint256 expectedPrize = 0.1 ether + 0.01 ether;
        assertEq(guesser.balance, guesserBalanceBefore + expectedPrize);
    }

    /**
     * @notice Test puzzle with maxNumber=65535 - incorrect guess
     */
    function test_MaxNumber65535_LargeSecret_IncorrectGuess() public {
        // Create puzzle with maxNumber=65535 and large secret (50000)
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.2 ether}(COMMITMENT_50000_999, 0.01 ether, 65535);

        // Submit incorrect guess (12345)
        vm.prank(guesser);
        uint256 challengeId = game.submitGuess{value: 0.01 ether}(puzzleId, 12345);

        uint256 guesserBalanceBefore = guesser.balance;

        // Respond with valid proof for incorrect guess
        vm.prank(creator);
        game.respondToChallenge(
            puzzleId,
            challengeId,
            validProofAIncorrect65535,
            validProofBIncorrect65535,
            validProofCIncorrect65535,
            validPubSignalsIncorrect65535
        );

        // Puzzle not solved
        assertFalse(game.getPuzzle(puzzleId).solved);

        // Guesser gets stake back
        assertEq(guesser.balance, guesserBalanceBefore + 0.01 ether);
    }

    /**
     * @notice Test that proof with wrong maxNumber is rejected
     */
    function test_MaxNumber_MismatchRejected() public {
        // Create puzzle with maxNumber=1000
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0.01 ether, 1000);

        // Submit guess
        vm.prank(guesser);
        uint256 challengeId = game.submitGuess{value: 0.01 ether}(puzzleId, 42);

        // Try to respond with proof for maxNumber=100 (mismatch)
        vm.prank(creator);
        vm.expectRevert(IGuessGame.InvalidProof.selector);
        game.respondToChallenge(
            puzzleId,
            challengeId,
            validProofACorrect,
            validProofBCorrect,
            validProofCCorrect,
            validPubSignalsCorrect // This has maxNumber=100, but puzzle has maxNumber=1000
        );
    }
}

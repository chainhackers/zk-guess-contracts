// SPDX-License-Identifier: MIT
pragma solidity ^0.8.30;

import "forge-std/Test.sol";
import "../src/GuessGame.sol";
import "../src/generated/GuessVerifier.sol";

contract GuessGameWithProofsTest is Test {
    Groth16Verifier public verifier;
    GuessGame public game;

    address creator;
    address guesser;
    address guesser2;

    // Test data with VALID ZK proofs generated by the actual circuit
    // For number=42, salt=123
    bytes32 constant COMMITMENT_42_123 = 0x1d869fb8246b6131377493aaaf1cc16a8284d4aedcb7277079df35d0d1d552d1;

    // Valid proof for correct guess (42)
    uint256[2] validProofA_correct = [
        5157887698177337623115911855277593515678867316837177621945040770006555507013,
        2906418579536343400716582440049667062559269406745718123049284811979351078961
    ];
    uint256[2][2] validProofB_correct = [
        [
            14332055634374331006889483633092758827337849388827220354213364180982843452222,
            19810903419040124121233668365857833379920314502394091870176177029284861054627
        ],
        [
            14914521979328201877060585819741683859740663954794671014405495630456970523413,
            5932921202897788419271490057837377976593298755559539853566958258387675310919
        ]
    ];
    uint256[2] validProofC_correct = [
        19225161834181317330543503779290557071354809366572782951390269839775729508986,
        2612633047517129916523257452953334712431527691991012490800657229613067565909
    ];
    uint256[2] validPubSignals_correct = [
        uint256(13354932457729771147254927911602504548850183657014898888488396374653942452945),
        1 // isCorrect = true
    ];

    // Valid proof for incorrect guess (50)
    uint256[2] validProofA_incorrect = [
        9758308845527562880152000047576342898199622908603024910972559233417444022851,
        13422093807828339412230457774329866784975316828562739791130382143618778496264
    ];
    uint256[2][2] validProofB_incorrect = [
        [
            9091300984639239739423744708847319435452500770118051644787336315262064631896,
            2270884553819703540920998596410221495666419821064349332236675366442618568527
        ],
        [
            14277132759968817182426864918099654463588513402666202713843117479877941998171,
            2239514721205042574478060827327107365740006011919760432858530138062064747403
        ]
    ];
    uint256[2] validProofC_incorrect = [
        4604401960742347972625156994490312017011144396786495069487929528815195101025,
        10202941257821071730828470950370450429224326502691136785274183779399028461980
    ];
    uint256[2] validPubSignals_incorrect = [
        uint256(13354932457729771147254927911602504548850183657014898888488396374653942452945),
        0 // isCorrect = false
    ];

    function setUp() public {
        // Create test addresses that can receive ETH
        creator = makeAddr("creator");
        guesser = makeAddr("guesser");
        guesser2 = makeAddr("guesser2");

        // Deploy verifier first
        verifier = new Groth16Verifier();
        // Deploy game with verifier address
        game = new GuessGame(address(verifier));

        vm.deal(creator, 10 ether);
        vm.deal(guesser, 10 ether);
        vm.deal(guesser2, 10 ether);
    }

    function test_RespondToChallenge_CorrectGuess_WithValidProof() public {
        // Create puzzle
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.1 ether}(COMMITMENT_42_123, 0.01 ether);

        // Submit correct guess
        vm.prank(guesser);
        uint256 challengeId = game.submitGuess{value: 0.01 ether}(puzzleId, 42);

        // Check initial state
        IGuessGame.Puzzle memory puzzleBefore = game.getPuzzle(puzzleId);
        assertEq(puzzleBefore.pendingChallenges, 1);
        assertEq(puzzleBefore.solved, false);

        uint256 guesserBalanceBefore = guesser.balance;

        // Respond with valid proof showing guess is correct
        vm.prank(creator);
        game.respondToChallenge(
            puzzleId, challengeId, validProofA_correct, validProofB_correct, validProofC_correct, validPubSignals_correct
        );

        // Verify puzzle is solved
        IGuessGame.Puzzle memory puzzleAfter = game.getPuzzle(puzzleId);
        assertEq(puzzleAfter.solved, true);
        assertEq(puzzleAfter.pendingChallenges, 0);

        // Verify challenge is marked as responded
        IGuessGame.Challenge memory challenge = game.getChallenge(puzzleId, challengeId);
        assertEq(challenge.responded, true);

        // Verify winner received bounty + stake
        uint256 expectedPrize = 0.1 ether + 0.01 ether; // bounty + stake
        assertEq(guesser.balance, guesserBalanceBefore + expectedPrize);
    }

    function test_RespondToChallenge_IncorrectGuess_WithValidProof() public {
        // Create puzzle
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.1 ether}(COMMITMENT_42_123, 0.01 ether);

        // Submit incorrect guess
        vm.prank(guesser);
        uint256 challengeId = game.submitGuess{value: 0.01 ether}(puzzleId, 50);

        uint256 guesserBalanceBefore = guesser.balance;

        // Respond with valid proof showing guess is incorrect
        vm.prank(creator);
        game.respondToChallenge(
            puzzleId,
            challengeId,
            validProofA_incorrect,
            validProofB_incorrect,
            validProofC_incorrect,
            validPubSignals_incorrect
        );

        // Verify puzzle is NOT solved
        IGuessGame.Puzzle memory puzzleAfter = game.getPuzzle(puzzleId);
        assertEq(puzzleAfter.solved, false);
        assertEq(puzzleAfter.pendingChallenges, 0);

        // Verify guesser got their stake back (simplified economics)
        assertEq(guesser.balance, guesserBalanceBefore + 0.01 ether);
    }

    function test_RespondToChallenge_MultipleGuesses_ThenCorrect() public {
        // Create puzzle
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.1 ether}(COMMITMENT_42_123, 0.01 ether);

        // First incorrect guess
        vm.prank(guesser);
        uint256 challengeId1 = game.submitGuess{value: 0.01 ether}(puzzleId, 50);

        uint256 guesser1BalanceBefore = guesser.balance;

        // Respond to first guess (incorrect) - guesser gets stake back
        vm.prank(creator);
        game.respondToChallenge(
            puzzleId,
            challengeId1,
            validProofA_incorrect,
            validProofB_incorrect,
            validProofC_incorrect,
            validPubSignals_incorrect
        );

        // Guesser should have stake back
        assertEq(guesser.balance, guesser1BalanceBefore + 0.01 ether);

        // Second incorrect guess from different guesser
        vm.prank(guesser2);
        uint256 challengeId2 = game.submitGuess{value: 0.01 ether}(puzzleId, 99);

        uint256 guesser2BalanceBefore = guesser2.balance;

        // For simplicity, reuse the same incorrect proof (in reality would be different)
        vm.prank(creator);
        game.respondToChallenge(
            puzzleId,
            challengeId2,
            validProofA_incorrect,
            validProofB_incorrect,
            validProofC_incorrect,
            validPubSignals_incorrect
        );

        // Guesser2 should have stake back
        assertEq(guesser2.balance, guesser2BalanceBefore + 0.01 ether);

        IGuessGame.Puzzle memory puzzleAfterIncorrect = game.getPuzzle(puzzleId);
        assertEq(puzzleAfterIncorrect.bounty, 0.1 ether); // Bounty unchanged
        assertEq(puzzleAfterIncorrect.pendingChallenges, 0);

        // Now submit correct guess
        uint256 guesserBalanceBefore = guesser.balance;
        vm.prank(guesser);
        uint256 challengeId3 = game.submitGuess{value: 0.01 ether}(puzzleId, 42);

        // Respond with correct proof
        vm.prank(creator);
        game.respondToChallenge(
            puzzleId, challengeId3, validProofA_correct, validProofB_correct, validProofC_correct, validPubSignals_correct
        );

        // Verify puzzle is solved
        IGuessGame.Puzzle memory puzzleFinal = game.getPuzzle(puzzleId);
        assertEq(puzzleFinal.solved, true);

        // Winner gets bounty + stake back
        uint256 expectedWinnerPrize = 0.1 ether + 0.01 ether;
        assertEq(guesser.balance, guesserBalanceBefore - 0.01 ether + expectedWinnerPrize);
    }

    function test_RespondToChallenge_AnyOrder() public {
        // Create puzzle
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.1 ether}(COMMITMENT_42_123, 0.01 ether);

        // Submit multiple guesses
        vm.prank(guesser);
        uint256 challengeId1 = game.submitGuess{value: 0.01 ether}(puzzleId, 50);

        vm.prank(guesser2);
        uint256 challengeId2 = game.submitGuess{value: 0.01 ether}(puzzleId, 99);

        // Respond out of order - challenge 2 first (should work with no queue enforcement)
        vm.prank(creator);
        game.respondToChallenge(
            puzzleId,
            challengeId2,
            validProofA_incorrect,
            validProofB_incorrect,
            validProofC_incorrect,
            validPubSignals_incorrect
        );

        // Then respond to challenge 1
        vm.prank(creator);
        game.respondToChallenge(
            puzzleId,
            challengeId1,
            validProofA_incorrect,
            validProofB_incorrect,
            validProofC_incorrect,
            validPubSignals_incorrect
        );

        // Both challenges responded
        IGuessGame.Challenge memory c1 = game.getChallenge(puzzleId, challengeId1);
        IGuessGame.Challenge memory c2 = game.getChallenge(puzzleId, challengeId2);
        assertEq(c1.responded, true);
        assertEq(c2.responded, true);
    }

    function test_RespondToChallenge_InvalidCommitment_Reverts() public {
        // Create puzzle
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.1 ether}(COMMITMENT_42_123, 0.01 ether);

        vm.prank(guesser);
        uint256 challengeId = game.submitGuess{value: 0.01 ether}(puzzleId, 42);

        // Create proof with wrong commitment
        uint256[2] memory wrongPubSignals = [
            uint256(0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef), // wrong commitment
            1
        ];

        vm.prank(creator);
        vm.expectRevert(IGuessGame.InvalidProof.selector);
        game.respondToChallenge(
            puzzleId, challengeId, validProofA_correct, validProofB_correct, validProofC_correct, wrongPubSignals
        );
    }

    function test_RespondToChallenge_AlreadyResponded_Reverts() public {
        // Create puzzle and submit guess
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.1 ether}(COMMITMENT_42_123, 0.01 ether);

        vm.prank(guesser);
        uint256 challengeId = game.submitGuess{value: 0.01 ether}(puzzleId, 50);

        // First response
        vm.prank(creator);
        game.respondToChallenge(
            puzzleId,
            challengeId,
            validProofA_incorrect,
            validProofB_incorrect,
            validProofC_incorrect,
            validPubSignals_incorrect
        );

        // Try to respond again
        vm.prank(creator);
        vm.expectRevert(IGuessGame.ChallengeAlreadyResponded.selector);
        game.respondToChallenge(
            puzzleId,
            challengeId,
            validProofA_incorrect,
            validProofB_incorrect,
            validProofC_incorrect,
            validPubSignals_incorrect
        );
    }

    function test_RespondToChallenge_PuzzleAlreadySolved_Reverts() public {
        // Create puzzle
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.1 ether}(COMMITMENT_42_123, 0.01 ether);

        // First guess (correct)
        vm.prank(guesser);
        uint256 challengeId1 = game.submitGuess{value: 0.01 ether}(puzzleId, 42);

        // Second guess
        vm.prank(guesser2);
        uint256 challengeId2 = game.submitGuess{value: 0.01 ether}(puzzleId, 50);

        // Solve puzzle with first guess
        vm.prank(creator);
        game.respondToChallenge(
            puzzleId, challengeId1, validProofA_correct, validProofB_correct, validProofC_correct, validPubSignals_correct
        );

        // Try to respond to second guess after puzzle is solved
        vm.prank(creator);
        vm.expectRevert(IGuessGame.PuzzleAlreadySolved.selector);
        game.respondToChallenge(
            puzzleId,
            challengeId2,
            validProofA_incorrect,
            validProofB_incorrect,
            validProofC_incorrect,
            validPubSignals_incorrect
        );
    }

    function test_CancelPuzzle_AfterAllResponsesProcessed() public {
        // Create puzzle
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.1 ether}(COMMITMENT_42_123, 0.01 ether);

        // Submit guess
        vm.prank(guesser);
        uint256 challengeId = game.submitGuess{value: 0.01 ether}(puzzleId, 50);

        // Can't cancel with pending challenges
        vm.prank(creator);
        vm.expectRevert(IGuessGame.HasPendingChallenges.selector);
        game.cancelPuzzle(puzzleId);

        // Respond to challenge (guesser gets stake back)
        vm.prank(creator);
        game.respondToChallenge(
            puzzleId,
            challengeId,
            validProofA_incorrect,
            validProofB_incorrect,
            validProofC_incorrect,
            validPubSignals_incorrect
        );

        uint256 creatorBalanceBefore = creator.balance;

        // Now can cancel
        vm.prank(creator);
        game.cancelPuzzle(puzzleId);

        // Creator gets bounty back
        assertEq(creator.balance, creatorBalanceBefore + 0.1 ether);

        IGuessGame.Puzzle memory puzzle = game.getPuzzle(puzzleId);
        assertEq(puzzle.cancelled, true);
    }
}

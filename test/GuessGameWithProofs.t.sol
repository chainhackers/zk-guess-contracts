// SPDX-License-Identifier: MIT
pragma solidity ^0.8.30;

import "forge-std/Test.sol";
import "../src/GuessGame.sol";
import "../src/generated/GuessVerifier.sol";

contract GuessGameWithProofsTest is Test {
    Groth16Verifier public verifier;
    GuessGame public game;
    
    address creator;
    address guesser;
    address guesser2;
    
    // Test data with VALID ZK proofs generated by the actual circuit
    // For number=42, salt=123
    bytes32 constant COMMITMENT_42_123 = 0x1d869fb8246b6131377493aaaf1cc16a8284d4aedcb7277079df35d0d1d552d1;
    
    // Valid proof for correct guess (42)
    uint[2] validProofA_correct = [
        5157887698177337623115911855277593515678867316837177621945040770006555507013,
        2906418579536343400716582440049667062559269406745718123049284811979351078961
    ];
    uint[2][2] validProofB_correct = [
        [14332055634374331006889483633092758827337849388827220354213364180982843452222,
         19810903419040124121233668365857833379920314502394091870176177029284861054627],
        [14914521979328201877060585819741683859740663954794671014405495630456970523413,
         5932921202897788419271490057837377976593298755559539853566958258387675310919]
    ];
    uint[2] validProofC_correct = [
        19225161834181317330543503779290557071354809366572782951390269839775729508986,
        2612633047517129916523257452953334712431527691991012490800657229613067565909
    ];
    uint[2] validPubSignals_correct = [
        uint256(13354932457729771147254927911602504548850183657014898888488396374653942452945),
        1 // isCorrect = true
    ];
    
    // Valid proof for incorrect guess (50)
    uint[2] validProofA_incorrect = [
        9758308845527562880152000047576342898199622908603024910972559233417444022851,
        13422093807828339412230457774329866784975316828562739791130382143618778496264
    ];
    uint[2][2] validProofB_incorrect = [
        [9091300984639239739423744708847319435452500770118051644787336315262064631896,
         2270884553819703540920998596410221495666419821064349332236675366442618568527],
        [14277132759968817182426864918099654463588513402666202713843117479877941998171,
         2239514721205042574478060827327107365740006011919760432858530138062064747403]
    ];
    uint[2] validProofC_incorrect = [
        4604401960742347972625156994490312017011144396786495069487929528815195101025,
        10202941257821071730828470950370450429224326502691136785274183779399028461980
    ];
    uint[2] validPubSignals_incorrect = [
        uint256(13354932457729771147254927911602504548850183657014898888488396374653942452945),
        0 // isCorrect = false
    ];
    
    function setUp() public {
        // Create test addresses that can receive ETH
        creator = makeAddr("creator");
        guesser = makeAddr("guesser");
        guesser2 = makeAddr("guesser2");
        
        // Deploy verifier first
        verifier = new Groth16Verifier();
        // Deploy game with verifier address
        game = new GuessGame(address(verifier));
        
        vm.deal(creator, 10 ether);
        vm.deal(guesser, 10 ether);
        vm.deal(guesser2, 10 ether);
    }
    
    function test_RespondToChallenge_CorrectGuess_WithValidProof() public {
        // Create puzzle
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.1 ether}(
            COMMITMENT_42_123,
            0.01 ether,
            50
        );
        
        // Submit correct guess
        vm.prank(guesser);
        uint256 challengeId = game.submitGuess{value: 0.01 ether}(puzzleId, 42);
        
        // Check initial state
        IGuessGame.Puzzle memory puzzleBefore = game.getPuzzle(puzzleId);
        assertEq(puzzleBefore.bounty, 0.1 ether);
        assertEq(puzzleBefore.solved, false);
        
        uint256 guesserBalanceBefore = guesser.balance;
        
        // Respond with valid proof showing guess is correct
        vm.prank(creator);
        game.respondToChallenge(
            challengeId,
            validProofA_correct,
            validProofB_correct,
            validProofC_correct,
            validPubSignals_correct
        );
        
        // Verify puzzle is solved
        IGuessGame.Puzzle memory puzzleAfter = game.getPuzzle(puzzleId);
        assertEq(puzzleAfter.solved, true);
        
        // Verify challenge is marked as responded
        IGuessGame.Challenge memory challenge = game.getChallenge(challengeId);
        assertEq(challenge.responded, true);
        
        // Verify winner received bounty + stake
        uint256 expectedPrize = 0.1 ether + 0.01 ether; // bounty + stake (no creator reward)
        assertEq(guesser.balance, guesserBalanceBefore + expectedPrize);
    }
    
    function test_RespondToChallenge_IncorrectGuess_WithValidProof() public {
        // Create puzzle
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.1 ether}(
            COMMITMENT_42_123,
            0.01 ether,
            50 // 50% growth
        );
        
        // Submit incorrect guess
        vm.prank(guesser);
        uint256 challengeId = game.submitGuess{value: 0.01 ether}(puzzleId, 50);
        
        // Check initial state
        IGuessGame.Puzzle memory puzzleBefore = game.getPuzzle(puzzleId);
        uint256 bountyBefore = puzzleBefore.bounty;
        
        uint256 creatorBalanceBefore = creator.balance;
        
        // Respond with valid proof showing guess is incorrect
        vm.prank(creator);
        game.respondToChallenge(
            challengeId,
            validProofA_incorrect,
            validProofB_incorrect,
            validProofC_incorrect,
            validPubSignals_incorrect
        );
        
        // Verify puzzle is NOT solved
        IGuessGame.Puzzle memory puzzleAfter = game.getPuzzle(puzzleId);
        assertEq(puzzleAfter.solved, false);
        
        // Verify bounty increased by 50% of stake (50% growth rate)
        assertEq(puzzleAfter.bounty, bountyBefore + 0.005 ether);
        
        // Verify creator reward is accumulated in puzzle (not transferred yet)
        assertEq(puzzleAfter.creatorReward, 0.005 ether);
        // Creator balance should remain unchanged
        assertEq(creator.balance, creatorBalanceBefore);
    }
    
    function test_RespondToChallenge_MultipleGuesses_ThenCorrect() public {
        // Create puzzle
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.1 ether}(
            COMMITMENT_42_123,
            0.01 ether,
            50
        );
        
        // First incorrect guess
        vm.prank(guesser);
        uint256 challengeId1 = game.submitGuess{value: 0.01 ether}(puzzleId, 50);
        
        // Respond to first guess (incorrect)
        vm.prank(creator);
        game.respondToChallenge(
            challengeId1,
            validProofA_incorrect,
            validProofB_incorrect,
            validProofC_incorrect,
            validPubSignals_incorrect
        );
        
        // Second incorrect guess from different guesser
        vm.prank(guesser2);
        uint256 challengeId2 = game.submitGuess{value: 0.01 ether}(puzzleId, 99);
        
        // For simplicity, reuse the same incorrect proof (in reality would be different)
        vm.prank(creator);
        game.respondToChallenge(
            challengeId2,
            validProofA_incorrect,
            validProofB_incorrect,
            validProofC_incorrect,
            validPubSignals_incorrect
        );
        
        IGuessGame.Puzzle memory puzzleAfterIncorrect = game.getPuzzle(puzzleId);
        assertEq(puzzleAfterIncorrect.bounty, 0.1 ether + 0.005 ether + 0.005 ether);
        assertEq(puzzleAfterIncorrect.creatorReward, 0.005 ether + 0.005 ether);
        
        // Log state after incorrect guesses
        console.log("After incorrect guesses:");
        console.log("  Bounty:", puzzleAfterIncorrect.bounty);
        console.log("  Creator reward:", puzzleAfterIncorrect.creatorReward);
        
        // Now submit correct guess
        uint256 guesserBalanceBefore = guesser.balance;
        vm.prank(guesser);
        uint256 challengeId3 = game.submitGuess{value: 0.01 ether}(puzzleId, 42);
        
        // Check contract balance before final response
        uint256 contractBalance = address(game).balance;
        assertEq(contractBalance, 0.13 ether); // 0.1 initial + 0.03 from stakes
        
        // Check expected payouts
        IGuessGame.Puzzle memory puzzleBeforeSolve = game.getPuzzle(puzzleId);
        IGuessGame.Challenge memory challenge3 = game.getChallenge(challengeId3);
        uint256 expectedWinnerPrize = puzzleBeforeSolve.bounty + challenge3.stake;
        uint256 expectedCreatorPayout = puzzleBeforeSolve.creatorReward;
        
        // Log values for debugging
        console.log("Before solving:");
        console.log("  Puzzle bounty:", puzzleBeforeSolve.bounty);
        console.log("  Creator reward:", puzzleBeforeSolve.creatorReward);
        console.log("Contract balance:", contractBalance);
        console.log("Expected winner prize:", expectedWinnerPrize);
        console.log("Expected creator payout:", expectedCreatorPayout);
        console.log("Total needed:", expectedWinnerPrize + expectedCreatorPayout);
        
        // Respond with correct proof
        vm.prank(creator);
        game.respondToChallenge(
            challengeId3,
            validProofA_correct,
            validProofB_correct,
            validProofC_correct,
            validPubSignals_correct
        );
        
        // Verify puzzle is solved
        IGuessGame.Puzzle memory puzzleFinal = game.getPuzzle(puzzleId);
        assertEq(puzzleFinal.solved, true);
        
        assertEq(guesser.balance, guesserBalanceBefore - 0.01 ether + expectedWinnerPrize);
    }
    
    function test_RespondToChallenge_InvalidCommitment_Reverts() public {
        // Create puzzle
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.1 ether}(
            COMMITMENT_42_123,
            0.01 ether,
            50
        );
        
        vm.prank(guesser);
        uint256 challengeId = game.submitGuess{value: 0.01 ether}(puzzleId, 42);
        
        // Create proof with wrong commitment
        uint[2] memory wrongPubSignals = [
            uint256(0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef), // wrong commitment
            1
        ];
        
        vm.prank(creator);
        vm.expectRevert(IGuessGame.InvalidProof.selector);
        game.respondToChallenge(
            challengeId,
            validProofA_correct,
            validProofB_correct,
            validProofC_correct,
            wrongPubSignals
        );
    }
    
    function test_RespondToChallenge_AlreadyResponded_Reverts() public {
        // Create puzzle and submit guess
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.1 ether}(
            COMMITMENT_42_123,
            0.01 ether,
            50
        );
        
        vm.prank(guesser);
        uint256 challengeId = game.submitGuess{value: 0.01 ether}(puzzleId, 50);
        
        // First response
        vm.prank(creator);
        game.respondToChallenge(
            challengeId,
            validProofA_incorrect,
            validProofB_incorrect,
            validProofC_incorrect,
            validPubSignals_incorrect
        );
        
        // Try to respond again
        vm.prank(creator);
        vm.expectRevert(IGuessGame.ChallengeAlreadyResponded.selector);
        game.respondToChallenge(
            challengeId,
            validProofA_incorrect,
            validProofB_incorrect,
            validProofC_incorrect,
            validPubSignals_incorrect
        );
    }
    
    function test_RespondToChallenge_PuzzleAlreadySolved_Reverts() public {
        // Create puzzle
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.1 ether}(
            COMMITMENT_42_123,
            0.01 ether,
            50
        );
        
        // First guess (correct)
        vm.prank(guesser);
        uint256 challengeId1 = game.submitGuess{value: 0.01 ether}(puzzleId, 42);
        
        // Second guess
        vm.prank(guesser2);
        uint256 challengeId2 = game.submitGuess{value: 0.01 ether}(puzzleId, 50);
        
        // Solve puzzle with first guess
        vm.prank(creator);
        game.respondToChallenge(
            challengeId1,
            validProofA_correct,
            validProofB_correct,
            validProofC_correct,
            validPubSignals_correct
        );
        
        // Try to respond to second guess after puzzle is solved
        vm.prank(creator);
        vm.expectRevert(IGuessGame.PuzzleAlreadySolved.selector);
        game.respondToChallenge(
            challengeId2,
            validProofA_incorrect,
            validProofB_incorrect,
            validProofC_incorrect,
            validPubSignals_incorrect
        );
    }

    function test_RespondToChallenge_InvalidChallengeResponseOrder() public {
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.1 ether}(
            COMMITMENT_42_123,
            0.01 ether,
            50
        );

        vm.prank(guesser);
        game.submitGuess{value: 0.01 ether}(puzzleId, 7);

        vm.prank(guesser2);
        uint256 challengeId2 = game.submitGuess{value: 0.01 ether}(puzzleId, 11);

        vm.startPrank(creator);
        vm.expectRevert(IGuessGame.InvalidChallengeResponseOrder.selector);
        game.respondToChallenge(
            challengeId2,
            validProofA_incorrect,
            validProofB_incorrect,
            validProofC_incorrect,
            validPubSignals_incorrect
        );
        vm.stopPrank();
    }

    function test_RespondToChallenge_ValidOrder() public {
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.1 ether}(
            COMMITMENT_42_123,
            0.01 ether,
            50
        );

        vm.prank(guesser);
        uint256 challengeId1 = game.submitGuess{value: 0.01 ether}(puzzleId, 7);

        vm.prank(guesser2);
        uint256 challengeId2 = game.submitGuess{value: 0.01 ether}(puzzleId, 11);

        vm.startPrank(creator);
        
        game.respondToChallenge(
            challengeId1,
            validProofA_incorrect,
            validProofB_incorrect,
            validProofC_incorrect,
            validPubSignals_incorrect
        );
        assertTrue(game.getChallenge(challengeId1).responded);

        game.respondToChallenge(
            challengeId2,
            validProofA_incorrect,
            validProofB_incorrect,
            validProofC_incorrect,
            validPubSignals_incorrect
        );
        assertTrue(game.getChallenge(challengeId2).responded);

        vm.stopPrank();
    }
}
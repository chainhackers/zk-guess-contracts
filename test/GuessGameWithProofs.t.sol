// SPDX-License-Identifier: MIT
pragma solidity ^0.8.30;

import "forge-std/Test.sol";
import "../src/GuessGame.sol";
import "../src/generated/GuessVerifier.sol";

contract GuessGameWithProofsTest is Test {
    Groth16Verifier public verifier;
    GuessGame public game;

    address creator;
    address guesser;
    address guesser2;

    // Test data with VALID ZK proofs generated by the actual circuit
    // For number=42, salt=123
    bytes32 constant COMMITMENT_42_123 = 0x1d869fb8246b6131377493aaaf1cc16a8284d4aedcb7277079df35d0d1d552d1;

    // Valid proof for correct guess (42)
    uint256[2] validProofA_correct = [
        20733104445222474913460899055922638733390515415268774731643134142498872084191,
        14000468808382636465462761302394038173719213862863751644422554851223456811411
    ];
    uint256[2][2] validProofB_correct = [
        [
            14529324359401080920218683234881556919213052277135946418796017114639319774385,
            12129083737057255635218975576710777788141717515839459178762095078342656790038
        ],
        [
            4006130398494418696741732007622629431845312574338850368957129174821663088541,
            5320382245369139568202711526684359871618209808068963385672210545364024687600
        ]
    ];
    uint256[2] validProofC_correct = [
        11555678601106434654959630063997038302724273931564919993607610338934924583422,
        12395595758571672800576038452878068084738676055843400774526791354550122500902
    ];
    uint256[3] validPubSignals_correct = [
        uint256(13354932457729771147254927911602504548850183657014898888488396374653942452945),
        1, // isCorrect = true
        42 //guess
    ];

    // Valid proof for incorrect guess (50)
    uint256[2] validProofA_incorrect = [
        260224852269514550962255596791713148069192103530930225168509498623216740997,
        3464936673232863366747749560095954607406672448198506930195439109614243395305
    ];
    uint256[2][2] validProofB_incorrect = [
        [
            18076787037990225159899307248733301104058781270403724423075272532649526747523,
            21163582130445499238873337568384386692136208661991064222861763232945956209076
        ],
        [
            14700551543044113104786011479044690264965500866720142037325671448170897252180,
            248536395010580566114959855988956594661021088223112251086687402479116093507
        ]
    ];
    uint256[2] validProofC_incorrect = [
        3718774677296111965628987936986701738438916711731522663485615268638604855259,
        15664470303899517099778638779831003600948012776255763324223926677414563225933
    ];
    uint256[3] validPubSignals_incorrect = [
        uint256(13354932457729771147254927911602504548850183657014898888488396374653942452945),
        0, // isCorrect = false
        50 //guess
    ];

    uint256[2] validProofA_incorrect_99 = [
        1522250115459347886732366836753121648149166765464232477792700654355908098958,
        12230247335391372868598697888961446586952358073485687489866514136177234102516
    ];
    uint256[2][2] validProofB_incorrect_99 = [
        [
            829808490343623106010157378861222277376158829827485398099043639305686191932,
            17794992986969421673750416099231395431613517939633365877256108996901124885408
        ],
        [
            13764104074731906666379119009729886488089352881221577140560629738823728313757,
            8228639052365462362835629439297935566254125449786065112616179334330818224187
        ]
    ];
    uint256[2] validProofC_incorrect_99 = [
        1477156412658329873137803094926985163386885774473985262711014984933715457935,
        13394207920715449173518714206562449218544155651180071706369101076169486617299
    ];
    uint256[3] validPubSignals_incorrect_99 = [
        uint256(13354932457729771147254927911602504548850183657014898888488396374653942452945),
        0, // isCorrect = false
        99 //guess
    ];

    address treasury;

    function setUp() public {
        // Create test addresses that can receive ETH
        creator = makeAddr("creator");
        guesser = makeAddr("guesser");
        guesser2 = makeAddr("guesser2");
        treasury = makeAddr("treasury");

        // Deploy verifier first
        verifier = new Groth16Verifier();
        // Deploy game with verifier address and treasury
        game = new GuessGame(address(verifier), treasury);

        vm.deal(creator, 10 ether);
        vm.deal(guesser, 10 ether);
        vm.deal(guesser2, 10 ether);
    }

    function test_RespondToChallenge_CorrectGuess_WithValidProof() public {
        // Create puzzle
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0.01 ether);

        // Submit correct guess
        vm.prank(guesser);
        uint256 challengeId = game.submitGuess{value: 0.01 ether}(puzzleId, 42);

        // Check initial state
        IGuessGame.Puzzle memory puzzleBefore = game.getPuzzle(puzzleId);
        assertEq(puzzleBefore.pendingChallenges, 1);
        assertEq(puzzleBefore.solved, false);

        uint256 guesserBalanceBefore = guesser.balance;

        // Respond with valid proof showing guess is correct
        vm.prank(creator);
        game.respondToChallenge(
            puzzleId,
            challengeId,
            validProofA_correct,
            validProofB_correct,
            validProofC_correct,
            validPubSignals_correct
        );

        // Verify puzzle is solved
        IGuessGame.Puzzle memory puzzleAfter = game.getPuzzle(puzzleId);
        assertEq(puzzleAfter.solved, true);
        assertEq(puzzleAfter.pendingChallenges, 0);

        // Verify challenge is marked as responded
        IGuessGame.Challenge memory challenge = game.getChallenge(puzzleId, challengeId);
        assertEq(challenge.responded, true);

        // Verify winner received bounty + stake
        uint256 expectedPrize = 0.1 ether + 0.01 ether; // bounty + stake
        assertEq(guesser.balance, guesserBalanceBefore + expectedPrize);
    }

    function test_RespondToChallenge_IncorrectGuess_WithValidProof() public {
        // Create puzzle
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0.01 ether);

        // Submit incorrect guess
        vm.prank(guesser);
        uint256 challengeId = game.submitGuess{value: 0.01 ether}(puzzleId, 50);

        uint256 guesserBalanceBefore = guesser.balance;

        // Respond with valid proof showing guess is incorrect
        vm.prank(creator);
        game.respondToChallenge(
            puzzleId,
            challengeId,
            validProofA_incorrect,
            validProofB_incorrect,
            validProofC_incorrect,
            validPubSignals_incorrect
        );

        // Verify puzzle is NOT solved
        IGuessGame.Puzzle memory puzzleAfter = game.getPuzzle(puzzleId);
        assertEq(puzzleAfter.solved, false);
        assertEq(puzzleAfter.pendingChallenges, 0);

        // Verify guesser got their stake back (simplified economics)
        assertEq(guesser.balance, guesserBalanceBefore + 0.01 ether);
    }

    function test_RespondToChallenge_MultipleGuesses_ThenCorrect() public {
        // Create puzzle
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0.01 ether);

        // First incorrect guess
        vm.prank(guesser);
        uint256 challengeId1 = game.submitGuess{value: 0.01 ether}(puzzleId, 50);

        uint256 guesser1BalanceBefore = guesser.balance;

        // Respond to first guess (incorrect) - guesser gets stake back
        vm.prank(creator);
        game.respondToChallenge(
            puzzleId,
            challengeId1,
            validProofA_incorrect,
            validProofB_incorrect,
            validProofC_incorrect,
            validPubSignals_incorrect
        );

        // Guesser should have stake back
        assertEq(guesser.balance, guesser1BalanceBefore + 0.01 ether);

        // Second incorrect guess from different guesser
        vm.prank(guesser2);
        uint256 challengeId2 = game.submitGuess{value: 0.01 ether}(puzzleId, 99);

        uint256 guesser2BalanceBefore = guesser2.balance;

        // Respond with proof for guess 99
        vm.prank(creator);
        game.respondToChallenge(
            puzzleId,
            challengeId2,
            validProofA_incorrect_99,
            validProofB_incorrect_99,
            validProofC_incorrect_99,
            validPubSignals_incorrect_99
        );

        // Guesser2 should have stake back
        assertEq(guesser2.balance, guesser2BalanceBefore + 0.01 ether);

        IGuessGame.Puzzle memory puzzleAfterIncorrect = game.getPuzzle(puzzleId);
        assertEq(puzzleAfterIncorrect.bounty, 0.1 ether); // Bounty unchanged
        assertEq(puzzleAfterIncorrect.pendingChallenges, 0);

        // Now submit correct guess
        uint256 guesserBalanceBefore = guesser.balance;
        vm.prank(guesser);
        uint256 challengeId3 = game.submitGuess{value: 0.01 ether}(puzzleId, 42);

        // Respond with correct proof
        vm.prank(creator);
        game.respondToChallenge(
            puzzleId,
            challengeId3,
            validProofA_correct,
            validProofB_correct,
            validProofC_correct,
            validPubSignals_correct
        );

        // Verify puzzle is solved
        IGuessGame.Puzzle memory puzzleFinal = game.getPuzzle(puzzleId);
        assertEq(puzzleFinal.solved, true);

        // Winner gets bounty + stake back
        uint256 expectedWinnerPrize = 0.1 ether + 0.01 ether;
        assertEq(guesser.balance, guesserBalanceBefore - 0.01 ether + expectedWinnerPrize);
    }

    function test_RespondToChallenge_AnyOrder() public {
        // Create puzzle
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0.01 ether);

        // Submit multiple guesses
        vm.prank(guesser);
        uint256 challengeId1 = game.submitGuess{value: 0.01 ether}(puzzleId, 50);

        vm.prank(guesser2);
        uint256 challengeId2 = game.submitGuess{value: 0.01 ether}(puzzleId, 99);

        // Respond out of order - challenge 2 first (should work with no queue enforcement)
        // Must use correct proof for guess 99
        vm.prank(creator);
        game.respondToChallenge(
            puzzleId,
            challengeId2,
            validProofA_incorrect_99,
            validProofB_incorrect_99,
            validProofC_incorrect_99,
            validPubSignals_incorrect_99
        );

        // Then respond to challenge 1 with proof for guess 50
        vm.prank(creator);
        game.respondToChallenge(
            puzzleId,
            challengeId1,
            validProofA_incorrect,
            validProofB_incorrect,
            validProofC_incorrect,
            validPubSignals_incorrect
        );

        // Both challenges responded
        IGuessGame.Challenge memory c1 = game.getChallenge(puzzleId, challengeId1);
        IGuessGame.Challenge memory c2 = game.getChallenge(puzzleId, challengeId2);
        assertEq(c1.responded, true);
        assertEq(c2.responded, true);
    }

    function test_RespondToChallenge_InvalidCommitment_Reverts() public {
        // Create puzzle
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0.01 ether);

        vm.prank(guesser);
        uint256 challengeId = game.submitGuess{value: 0.01 ether}(puzzleId, 42);

        // Create proof with wrong commitment
        uint256[3] memory wrongPubSignals = [
            uint256(0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef), // wrong commitment
            1,
            42
        ];

        vm.prank(creator);
        vm.expectRevert(IGuessGame.InvalidProof.selector);
        game.respondToChallenge(
            puzzleId, challengeId, validProofA_correct, validProofB_correct, validProofC_correct, wrongPubSignals
        );
    }

    function test_RespondToChallenge_InvalidProofForChallengeGuess() public {
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0.01 ether);

        // Guesser submits guess 11
        vm.prank(guesser);
        uint256 challengeId = game.submitGuess{value: 0.01 ether}(puzzleId, 11);

        // Guesser submits guess 42
        vm.prank(guesser);
        uint256 challengeId1 = game.submitGuess{value: 0.01 ether}(puzzleId, 42);

        // Try to respond to challenge for guess 11 with proof for guess 42 - should fail
        vm.prank(creator);
        vm.expectRevert(IGuessGame.InvalidProofForChallengeGuess.selector);
        game.respondToChallenge(
            puzzleId,
            challengeId,
            validProofA_correct,
            validProofB_correct,
            validProofC_correct,
            validPubSignals_correct
        );

        // Try to respond to challenge for guess 42 with proof for guess 99 - should fail
        vm.prank(creator);
        vm.expectRevert(IGuessGame.InvalidProofForChallengeGuess.selector);
        game.respondToChallenge(
            puzzleId,
            challengeId1,
            validProofA_incorrect_99,
            validProofB_incorrect_99,
            validProofC_incorrect_99,
            validPubSignals_incorrect_99
        );
    }

    function test_RespondToChallenge_AlreadyResponded_Reverts() public {
        // Create puzzle and submit guess
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0.01 ether);

        vm.prank(guesser);
        uint256 challengeId = game.submitGuess{value: 0.01 ether}(puzzleId, 50);

        // First response
        vm.prank(creator);
        game.respondToChallenge(
            puzzleId,
            challengeId,
            validProofA_incorrect,
            validProofB_incorrect,
            validProofC_incorrect,
            validPubSignals_incorrect
        );

        // Try to respond again
        vm.prank(creator);
        vm.expectRevert(IGuessGame.ChallengeAlreadyResponded.selector);
        game.respondToChallenge(
            puzzleId,
            challengeId,
            validProofA_incorrect,
            validProofB_incorrect,
            validProofC_incorrect,
            validPubSignals_incorrect
        );
    }

    function test_RespondToChallenge_PuzzleAlreadySolved_Reverts() public {
        // Create puzzle
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0.01 ether);

        // First guess (correct)
        vm.prank(guesser);
        uint256 challengeId1 = game.submitGuess{value: 0.01 ether}(puzzleId, 42);

        // Second guess
        vm.prank(guesser2);
        uint256 challengeId2 = game.submitGuess{value: 0.01 ether}(puzzleId, 50);

        // Solve puzzle with first guess
        vm.prank(creator);
        game.respondToChallenge(
            puzzleId,
            challengeId1,
            validProofA_correct,
            validProofB_correct,
            validProofC_correct,
            validPubSignals_correct
        );

        // Try to respond to second guess after puzzle is solved
        vm.prank(creator);
        vm.expectRevert(IGuessGame.PuzzleAlreadySolved.selector);
        game.respondToChallenge(
            puzzleId,
            challengeId2,
            validProofA_incorrect,
            validProofB_incorrect,
            validProofC_incorrect,
            validPubSignals_incorrect
        );
    }

    function test_CancelPuzzle_AfterAllResponsesProcessed() public {
        // Create puzzle
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0.01 ether);

        // Submit guess
        vm.prank(guesser);
        uint256 challengeId = game.submitGuess{value: 0.01 ether}(puzzleId, 50);

        // Can't cancel with pending challenges
        vm.prank(creator);
        vm.expectRevert(IGuessGame.HasPendingChallenges.selector);
        game.cancelPuzzle(puzzleId);

        // Respond to challenge (guesser gets stake back)
        vm.prank(creator);
        game.respondToChallenge(
            puzzleId,
            challengeId,
            validProofA_incorrect,
            validProofB_incorrect,
            validProofC_incorrect,
            validPubSignals_incorrect
        );

        // Can't cancel yet - timeout hasn't passed
        vm.prank(creator);
        vm.expectRevert(IGuessGame.CancelTooSoon.selector);
        game.cancelPuzzle(puzzleId);

        // Warp time past the timeout
        vm.warp(block.timestamp + game.CANCEL_TIMEOUT() + 1);

        uint256 creatorBalanceBefore = creator.balance;

        // Now can cancel after timeout
        vm.prank(creator);
        game.cancelPuzzle(puzzleId);

        // Creator gets bounty + collateral back
        assertEq(creator.balance, creatorBalanceBefore + 0.2 ether);

        IGuessGame.Puzzle memory puzzle = game.getPuzzle(puzzleId);
        assertEq(puzzle.cancelled, true);
    }

    // ============ Forfeit Tests with Proofs ============

    function test_RespondToChallenge_PuzzleForfeited_Reverts() public {
        // Create puzzle
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0.01 ether);

        // Submit guess
        vm.prank(guesser);
        uint256 challengeId = game.submitGuess{value: 0.01 ether}(puzzleId, 50);

        // Warp time and forfeit
        vm.warp(block.timestamp + game.RESPONSE_TIMEOUT() + 1);
        game.forfeitPuzzle(puzzleId, challengeId);

        // Try to respond after forfeit - should fail
        vm.prank(creator);
        vm.expectRevert(IGuessGame.PuzzleForfeitedError.selector);
        game.respondToChallenge(
            puzzleId,
            challengeId,
            validProofA_incorrect,
            validProofB_incorrect,
            validProofC_incorrect,
            validPubSignals_incorrect
        );
    }

    function test_ForfeitPuzzle_ChallengeAlreadyResponded_Reverts() public {
        // Create puzzle
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0.01 ether);

        // Submit two guesses
        vm.prank(guesser);
        uint256 challengeId1 = game.submitGuess{value: 0.01 ether}(puzzleId, 50);

        vm.prank(guesser2);
        uint256 challengeId2 = game.submitGuess{value: 0.01 ether}(puzzleId, 99);

        // Respond to challenge 1
        vm.prank(creator);
        game.respondToChallenge(
            puzzleId,
            challengeId1,
            validProofA_incorrect,
            validProofB_incorrect,
            validProofC_incorrect,
            validPubSignals_incorrect
        );

        // Warp time
        vm.warp(block.timestamp + game.RESPONSE_TIMEOUT() + 1);

        // Try to forfeit using the responded challenge - should fail
        vm.expectRevert(IGuessGame.ChallengeAlreadyResponded.selector);
        game.forfeitPuzzle(puzzleId, challengeId1);

        // But can forfeit using challenge 2 (which was not responded)
        game.forfeitPuzzle(puzzleId, challengeId2);

        IGuessGame.Puzzle memory puzzle = game.getPuzzle(puzzleId);
        assertEq(puzzle.forfeited, true);
        assertEq(puzzle.pendingAtForfeit, 1); // Only challengeId2 was pending
    }

    function test_ForfeitAndClaim_AfterPartialResponses() public {
        // Create puzzle with 0.12 ether bounty (0.24 total = 0.12 bounty + 0.12 collateral, divisible by 2)
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.24 ether}(COMMITMENT_42_123, 0.01 ether);

        // Submit three guesses
        vm.prank(guesser);
        uint256 challengeId1 = game.submitGuess{value: 0.01 ether}(puzzleId, 50);

        vm.prank(guesser2);
        uint256 challengeId2 = game.submitGuess{value: 0.01 ether}(puzzleId, 99);

        address guesser3 = makeAddr("guesser3");
        vm.deal(guesser3, 10 ether);
        vm.prank(guesser3);
        uint256 challengeId3 = game.submitGuess{value: 0.01 ether}(puzzleId, 77);

        // Creator responds to challenge 1 only (guesser gets stake back)
        vm.prank(creator);
        game.respondToChallenge(
            puzzleId,
            challengeId1,
            validProofA_incorrect,
            validProofB_incorrect,
            validProofC_incorrect,
            validPubSignals_incorrect
        );

        // Warp time past timeout
        vm.warp(block.timestamp + game.RESPONSE_TIMEOUT() + 1);

        // Forfeit using challenge 2
        game.forfeitPuzzle(puzzleId, challengeId2);

        IGuessGame.Puzzle memory puzzle = game.getPuzzle(puzzleId);
        assertEq(puzzle.forfeited, true);
        assertEq(puzzle.pendingAtForfeit, 2); // challenges 2 and 3 were pending

        // Both pending guessers claim (single call per guesser)
        vm.prank(guesser2);
        game.claimFromForfeited(puzzleId);

        vm.prank(guesser3);
        game.claimFromForfeited(puzzleId);

        // Each gets stake (0.01) + bounty share (0.12 / 2 = 0.06)
        assertEq(game.balances(guesser2), 0.01 ether + 0.06 ether);
        assertEq(game.balances(guesser3), 0.01 ether + 0.06 ether);

        // Withdraw
        uint256 guesser2BalanceBefore = guesser2.balance;
        uint256 guesser3BalanceBefore = guesser3.balance;

        vm.prank(guesser2);
        game.withdraw();
        vm.prank(guesser3);
        game.withdraw();

        assertEq(guesser2.balance, guesser2BalanceBefore + 0.07 ether);
        assertEq(guesser3.balance, guesser3BalanceBefore + 0.07 ether);

        // guesser (who was responded to) has no pending challenges to claim
        vm.prank(guesser);
        vm.expectRevert(IGuessGame.NothingToClaim.selector);
        game.claimFromForfeited(puzzleId);
    }

    // ============ Multi-Operation Scenario Test ============

    /**
     * @notice Complete game flow test:
     * 1. Creator creates a puzzle
     * 2. 2 guessers submit wrong guesses
     * 3. Creator tries to submit proofs for wrong guess numbers and fails
     * 4. Creator submits proper proofs (guessers get stakes back)
     * 5. 3rd guesser submits the right answer
     * 6. Creator responds and guesser wins bounty + stake
     */
    function test_CompleteGameFlow_WrongProofsThenCorrectWin() public {
        // Track balances
        uint256 creatorStartBalance = creator.balance;
        uint256 guesser1StartBalance = guesser.balance;
        uint256 guesser2StartBalance = guesser2.balance;

        // ========== Step 1: Creator creates puzzle ==========
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0.01 ether);

        assertEq(creator.balance, creatorStartBalance - 0.2 ether);

        IGuessGame.Puzzle memory puzzle = game.getPuzzle(puzzleId);
        assertEq(puzzle.creator, creator);
        assertEq(puzzle.bounty, 0.1 ether);
        assertEq(puzzle.collateral, 0.1 ether);
        assertEq(puzzle.solved, false);

        // ========== Step 2: 2 guessers submit wrong guesses ==========
        // Guesser 1 guesses 50 (wrong)
        vm.prank(guesser);
        uint256 challengeId1 = game.submitGuess{value: 0.01 ether}(puzzleId, 50);
        assertEq(guesser.balance, guesser1StartBalance - 0.01 ether);

        // Guesser 2 guesses 99 (wrong)
        vm.prank(guesser2);
        uint256 challengeId2 = game.submitGuess{value: 0.01 ether}(puzzleId, 99);
        assertEq(guesser2.balance, guesser2StartBalance - 0.01 ether);

        puzzle = game.getPuzzle(puzzleId);
        assertEq(puzzle.pendingChallenges, 2);
        assertEq(puzzle.challengeCount, 2);

        // ========== Step 3: Creator tries wrong proofs and fails ==========
        // Try to respond to challenge for guess 50 with proof for guess 99
        vm.prank(creator);
        vm.expectRevert(IGuessGame.InvalidProofForChallengeGuess.selector);
        game.respondToChallenge(
            puzzleId,
            challengeId1, // challenge for guess 50
            validProofA_incorrect_99,
            validProofB_incorrect_99,
            validProofC_incorrect_99,
            validPubSignals_incorrect_99 // proof for guess 99
        );

        // Try to respond to challenge for guess 99 with proof for guess 50
        vm.prank(creator);
        vm.expectRevert(IGuessGame.InvalidProofForChallengeGuess.selector);
        game.respondToChallenge(
            puzzleId,
            challengeId2, // challenge for guess 99
            validProofA_incorrect,
            validProofB_incorrect,
            validProofC_incorrect,
            validPubSignals_incorrect // proof for guess 50
        );

        // Try to respond to wrong guess with correct proof (proof says correct but guess wasn't 42)
        vm.prank(creator);
        vm.expectRevert(IGuessGame.InvalidProofForChallengeGuess.selector);
        game.respondToChallenge(
            puzzleId,
            challengeId1, // challenge for guess 50
            validProofA_correct,
            validProofB_correct,
            validProofC_correct,
            validPubSignals_correct // proof for guess 42 (correct answer)
        );

        // Challenges should still be pending
        puzzle = game.getPuzzle(puzzleId);
        assertEq(puzzle.pendingChallenges, 2);

        // ========== Step 4: Creator submits proper proofs ==========
        // Respond to guess 50 with proof for guess 50
        vm.prank(creator);
        game.respondToChallenge(
            puzzleId,
            challengeId1,
            validProofA_incorrect,
            validProofB_incorrect,
            validProofC_incorrect,
            validPubSignals_incorrect
        );

        // Guesser 1 should have stake back
        assertEq(guesser.balance, guesser1StartBalance);

        // Respond to guess 99 with proof for guess 99
        vm.prank(creator);
        game.respondToChallenge(
            puzzleId,
            challengeId2,
            validProofA_incorrect_99,
            validProofB_incorrect_99,
            validProofC_incorrect_99,
            validPubSignals_incorrect_99
        );

        // Guesser 2 should have stake back
        assertEq(guesser2.balance, guesser2StartBalance);

        // Puzzle should still be unsolved with no pending challenges
        puzzle = game.getPuzzle(puzzleId);
        assertEq(puzzle.solved, false);
        assertEq(puzzle.pendingChallenges, 0);
        assertEq(puzzle.bounty, 0.1 ether); // Bounty intact

        // ========== Step 5: 3rd guesser submits the right answer ==========
        address guesser3 = makeAddr("guesser3");
        vm.deal(guesser3, 10 ether);
        uint256 guesser3StartBalance = guesser3.balance;

        vm.prank(guesser3);
        uint256 challengeId3 = game.submitGuess{value: 0.01 ether}(puzzleId, 42);

        assertEq(guesser3.balance, guesser3StartBalance - 0.01 ether);

        puzzle = game.getPuzzle(puzzleId);
        assertEq(puzzle.pendingChallenges, 1);
        assertEq(puzzle.challengeCount, 3);

        // ========== Step 6: Creator responds, guesser wins bounty + stake ==========
        vm.prank(creator);
        game.respondToChallenge(
            puzzleId,
            challengeId3,
            validProofA_correct,
            validProofB_correct,
            validProofC_correct,
            validPubSignals_correct
        );

        // Verify final state
        puzzle = game.getPuzzle(puzzleId);
        assertEq(puzzle.solved, true);
        assertEq(puzzle.pendingChallenges, 0);

        // Winner (guesser3) gets bounty + stake
        uint256 expectedWinnerPrize = 0.1 ether + 0.01 ether;
        assertEq(guesser3.balance, guesser3StartBalance - 0.01 ether + expectedWinnerPrize);
        assertEq(guesser3.balance, guesser3StartBalance + 0.1 ether); // Net gain = bounty

        // Creator's ETH balance is down 0.2 ether (initial payment), but collateral credited to internal balance
        assertEq(creator.balance, creatorStartBalance - 0.2 ether);
        assertEq(game.balances(creator), 0.1 ether); // Collateral returned

        // Guesser 1 and 2 are back to original balances (stakes returned)
        assertEq(guesser.balance, guesser1StartBalance);
        assertEq(guesser2.balance, guesser2StartBalance);

        // Verify challenges are marked as responded
        IGuessGame.Challenge memory c1 = game.getChallenge(puzzleId, challengeId1);
        IGuessGame.Challenge memory c2 = game.getChallenge(puzzleId, challengeId2);
        IGuessGame.Challenge memory c3 = game.getChallenge(puzzleId, challengeId3);
        assertEq(c1.responded, true);
        assertEq(c2.responded, true);
        assertEq(c3.responded, true);
    }

    /**
     * @notice Test that creator can respond to challenges in any order
     * Challenges submitted: 1, 2 (with guesses 50, 99)
     * Responses given: 2, 1 (reverse order)
     * Note: Limited to 2 challenges because we only have valid proofs for guesses 50 and 99
     */
    function test_ResponsesInAnyOrder() public {
        // Create puzzle
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0.01 ether);

        // Submit 2 guesses in order (we only have proofs for 50 and 99)
        vm.prank(guesser);
        uint256 challengeId1 = game.submitGuess{value: 0.01 ether}(puzzleId, 50);

        vm.prank(guesser2);
        uint256 challengeId2 = game.submitGuess{value: 0.01 ether}(puzzleId, 99);

        IGuessGame.Puzzle memory puzzle = game.getPuzzle(puzzleId);
        assertEq(puzzle.pendingChallenges, 2);

        // Respond in reverse order: 2, 1 (not submission order)

        // First respond to challenge 2 (guess 99)
        vm.prank(creator);
        game.respondToChallenge(
            puzzleId,
            challengeId2,
            validProofA_incorrect_99,
            validProofB_incorrect_99,
            validProofC_incorrect_99,
            validPubSignals_incorrect_99
        );

        puzzle = game.getPuzzle(puzzleId);
        assertEq(puzzle.pendingChallenges, 1);
        assertEq(game.getChallenge(puzzleId, challengeId2).responded, true);
        assertEq(game.getChallenge(puzzleId, challengeId1).responded, false);

        // Then respond to challenge 1 (guess 50)
        vm.prank(creator);
        game.respondToChallenge(
            puzzleId,
            challengeId1,
            validProofA_incorrect,
            validProofB_incorrect,
            validProofC_incorrect,
            validPubSignals_incorrect
        );

        puzzle = game.getPuzzle(puzzleId);
        assertEq(puzzle.pendingChallenges, 0);
        assertEq(game.getChallenge(puzzleId, challengeId1).responded, true);

        // All responded, puzzle still unsolved
        assertEq(puzzle.solved, false);
    }

    /**
     * @notice Test that after forfeit, guessers can claim in any order
     * Guessers: 1, 2, 3, 4
     * Claims made: 4, 2, 1, 3 (random order)
     */
    function test_ForfeitClaimsInAnyOrder() public {
        // Create puzzle with bounty divisible by 4
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0.01 ether);

        // Create 4 guessers and submit guesses
        address guesser3 = makeAddr("guesser3");
        address guesser4 = makeAddr("guesser4");
        vm.deal(guesser3, 10 ether);
        vm.deal(guesser4, 10 ether);

        uint256 guesser1Start = guesser.balance;
        uint256 guesser2Start = guesser2.balance;
        uint256 guesser3Start = guesser3.balance;
        uint256 guesser4Start = guesser4.balance;

        vm.prank(guesser);
        game.submitGuess{value: 0.01 ether}(puzzleId, 50);

        vm.prank(guesser2);
        game.submitGuess{value: 0.01 ether}(puzzleId, 99);

        vm.prank(guesser3);
        game.submitGuess{value: 0.01 ether}(puzzleId, 77);

        vm.prank(guesser4);
        game.submitGuess{value: 0.01 ether}(puzzleId, 88);

        IGuessGame.Puzzle memory puzzle = game.getPuzzle(puzzleId);
        assertEq(puzzle.pendingChallenges, 4);

        // Warp time past timeout and forfeit
        vm.warp(block.timestamp + game.RESPONSE_TIMEOUT() + 1);
        game.forfeitPuzzle(puzzleId, 0);

        puzzle = game.getPuzzle(puzzleId);
        assertEq(puzzle.forfeited, true);
        assertEq(puzzle.pendingAtForfeit, 4);

        // Bounty is 0.1 ether (half of 0.2 ether total)
        // Each guesser should get: stake (0.01) + bounty share (0.1 / 4 = 0.025)
        uint256 expectedPayout = 0.01 ether + 0.025 ether;

        // Claim in order: 4, 2, 1, 3 (not submission order) - single call per guesser
        vm.prank(guesser4);
        game.claimFromForfeited(puzzleId);
        assertEq(game.balances(guesser4), expectedPayout);

        vm.prank(guesser2);
        game.claimFromForfeited(puzzleId);
        assertEq(game.balances(guesser2), expectedPayout);

        vm.prank(guesser);
        game.claimFromForfeited(puzzleId);
        assertEq(game.balances(guesser), expectedPayout);

        vm.prank(guesser3);
        game.claimFromForfeited(puzzleId);
        assertEq(game.balances(guesser3), expectedPayout);

        // Withdraw all
        vm.prank(guesser4);
        game.withdraw();
        vm.prank(guesser2);
        game.withdraw();
        vm.prank(guesser);
        game.withdraw();
        vm.prank(guesser3);
        game.withdraw();

        // Verify net gains: each guesser gained 0.025 ether (their share of 0.1 ether bounty / 4)
        assertEq(guesser.balance, guesser1Start + 0.025 ether);
        assertEq(guesser2.balance, guesser2Start + 0.025 ether);
        assertEq(guesser3.balance, guesser3Start + 0.025 ether);
        assertEq(guesser4.balance, guesser4Start + 0.025 ether);
    }

    // ============ Protocol Hole Tests (These SHOULD FAIL until fixed) ============

    /**
     * @notice Test that guessers can recover stakes when puzzle is solved with pending challenges
     *
     * Scenario:
     * 1. Guesser A submits correct guess (42)
     * 2. Guesser B submits wrong guess (50)
     * 3. Creator responds to A first â†’ puzzle solved, A wins
     * 4. Guesser B can call claimStakeFromSolved to recover their stake
     */
    function test_ClaimStakeFromSolved() public {
        // Create puzzle
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0.01 ether);

        uint256 guesser1Start = guesser.balance;
        uint256 guesser2Start = guesser2.balance;

        // Guesser 1 submits correct guess (42)
        vm.prank(guesser);
        uint256 challengeId1 = game.submitGuess{value: 0.01 ether}(puzzleId, 42);

        // Guesser 2 submits wrong guess (50)
        vm.prank(guesser2);
        uint256 challengeId2 = game.submitGuess{value: 0.01 ether}(puzzleId, 50);

        // Creator responds to guesser 1 (correct) - puzzle is solved
        vm.prank(creator);
        game.respondToChallenge(
            puzzleId,
            challengeId1,
            validProofA_correct,
            validProofB_correct,
            validProofC_correct,
            validPubSignals_correct
        );

        // Guesser 1 wins bounty + stake
        assertEq(guesser.balance, guesser1Start + 0.1 ether);

        // Puzzle is solved, guesser 2's challenge is still pending
        IGuessGame.Puzzle memory puzzle = game.getPuzzle(puzzleId);
        assertEq(puzzle.solved, true);

        // Guesser 2 claims their stake back (single call)
        vm.prank(guesser2);
        game.claimStakeFromSolved(puzzleId);

        // Balance should be credited
        assertEq(game.balances(guesser2), 0.01 ether);

        // Withdraw
        vm.prank(guesser2);
        game.withdraw();

        // Guesser 2 should have their stake returned
        assertEq(guesser2.balance, guesser2Start, "Guesser 2 should have stake returned");

        // Creator has collateral in internal balance
        assertEq(game.balances(creator), 0.1 ether, "Creator should have collateral in balance");

        // Creator withdraws collateral
        vm.prank(creator);
        game.withdraw();

        // Contract should have no funds left
        assertEq(address(game).balance, 0, "Contract should have no stuck funds");
    }

    /**
     * @notice Test bounty distribution with rounding
     *
     * With per-guesser aggregates, each guesser gets proportional share.
     * Minimal dust (1-2 wei) may remain in contract from integer division.
     */
    function test_BountyDistributionWithRounding() public {
        // Create puzzle with bounty that won't divide evenly by 3
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0.01 ether);

        // Create 3 guessers
        address guesser3 = makeAddr("guesser3");
        vm.deal(guesser3, 10 ether);

        uint256 guesser1Start = guesser.balance;
        uint256 guesser2Start = guesser2.balance;
        uint256 guesser3Start = guesser3.balance;

        // All 3 submit guesses (unique numbers)
        vm.prank(guesser);
        game.submitGuess{value: 0.01 ether}(puzzleId, 50);

        vm.prank(guesser2);
        game.submitGuess{value: 0.01 ether}(puzzleId, 99);

        vm.prank(guesser3);
        game.submitGuess{value: 0.01 ether}(puzzleId, 77);

        // Forfeit the puzzle
        vm.warp(block.timestamp + game.RESPONSE_TIMEOUT() + 1);
        game.forfeitPuzzle(puzzleId, 0);

        // Calculate expected shares
        uint256 bounty = 0.1 ether;
        uint256 bountyShare = bounty / 3; // 33333333333333333 wei

        // All guessers claim (single call each)
        vm.prank(guesser);
        game.claimFromForfeited(puzzleId);

        vm.prank(guesser2);
        game.claimFromForfeited(puzzleId);

        vm.prank(guesser3);
        game.claimFromForfeited(puzzleId);

        // Verify balances credited
        assertEq(game.balances(guesser), 0.01 ether + bountyShare);
        assertEq(game.balances(guesser2), 0.01 ether + bountyShare);
        assertEq(game.balances(guesser3), 0.01 ether + bountyShare);

        // Withdraw all
        vm.prank(guesser);
        game.withdraw();
        vm.prank(guesser2);
        game.withdraw();
        vm.prank(guesser3);
        game.withdraw();

        // Each guesser gained their bounty share
        assertEq(guesser.balance, guesser1Start + bountyShare);
        assertEq(guesser2.balance, guesser2Start + bountyShare);
        assertEq(guesser3.balance, guesser3Start + bountyShare);
    }

    // ============ Protocol Issue Tests ============

    /**
     * @notice Protocol should enforce minimum stake at puzzle creation
     */
    function test_MinimumStakeRequired() public {
        vm.prank(creator);
        vm.expectRevert(IGuessGame.InsufficientStake.selector);
        game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0);
    }

    /**
     * @notice Same guesser can submit multiple challenges (by design)
     *
     * This is acceptable because guessers risk their own funds. The "dilution attack"
     * mentioned in GitHub Issue #10 requires attacker to stake their own funds,
     * and forfeit is a recovery mechanism, not the intended path.
     */
    function test_SameGuesserMultipleChallenges_DesignDecision() public {
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0.01 ether);

        uint256 guesserStart = guesser.balance;

        // Same guesser submits 3 different guesses
        vm.prank(guesser);
        game.submitGuess{value: 0.01 ether}(puzzleId, 50);

        vm.prank(guesser);
        game.submitGuess{value: 0.01 ether}(puzzleId, 99);

        vm.prank(guesser);
        game.submitGuess{value: 0.01 ether}(puzzleId, 77);

        assertEq(guesser.balance, guesserStart - 0.03 ether);

        vm.warp(block.timestamp + game.RESPONSE_TIMEOUT() + 1);
        game.forfeitPuzzle(puzzleId, 0);

        IGuessGame.Puzzle memory puzzle = game.getPuzzle(puzzleId);
        assertEq(puzzle.pendingAtForfeit, 3);

        // Single claim for all challenges
        vm.prank(guesser);
        game.claimFromForfeited(puzzleId);

        // Balance credited: 3 stakes + entire bounty (3/3 share)
        assertEq(game.balances(guesser), 0.03 ether + 0.1 ether);

        // Withdraw
        vm.prank(guesser);
        game.withdraw();

        // Guesser gets stakes back + entire bounty
        assertEq(guesser.balance, guesserStart + 0.1 ether);
    }

    /**
     * @notice Creator cannot guess their own puzzle
     *
     * Related: GitHub Issue #10 - https://github.com/chainhackers/zk-guess-contracts/issues/10
     */
    function test_CreatorCannotSelfGuess() public {
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0.01 ether);

        vm.prank(creator);
        vm.expectRevert(IGuessGame.CreatorCannotGuess.selector);
        game.submitGuess{value: 0.01 ether}(puzzleId, 42);
    }

    /**
     * @notice Two players claim for 3 guesses where one player has 2 guesses
     *
     * Guesser1: 2 challenges (0.01 + 0.02 = 0.03 ether stake)
     * Guesser2: 1 challenge (0.01 ether stake)
     * Bounty: 0.15 ether, split by challenge count (2:1)
     */
    function test_TwoPlayersClaim_OneWithMultipleGuesses() public {
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.3 ether}(COMMITMENT_42_123, 0.01 ether);

        uint256 guesser1Start = guesser.balance;
        uint256 guesser2Start = guesser2.balance;

        // Guesser1 submits 2 guesses
        vm.prank(guesser);
        game.submitGuess{value: 0.01 ether}(puzzleId, 50);

        vm.prank(guesser);
        game.submitGuess{value: 0.02 ether}(puzzleId, 99);

        // Guesser2 submits 1 guess
        vm.prank(guesser2);
        game.submitGuess{value: 0.01 ether}(puzzleId, 77);

        // Forfeit
        vm.warp(block.timestamp + game.RESPONSE_TIMEOUT() + 1);
        game.forfeitPuzzle(puzzleId, 0);

        IGuessGame.Puzzle memory puzzle = game.getPuzzle(puzzleId);
        assertEq(puzzle.pendingAtForfeit, 3);

        // Both claim (single call each)
        vm.prank(guesser);
        game.claimFromForfeited(puzzleId);

        vm.prank(guesser2);
        game.claimFromForfeited(puzzleId);

        // Guesser1: stake (0.03) + bounty share (0.15 * 2/3 = 0.1)
        assertEq(game.balances(guesser), 0.03 ether + 0.1 ether);

        // Guesser2: stake (0.01) + bounty share (0.15 * 1/3 = 0.05)
        assertEq(game.balances(guesser2), 0.01 ether + 0.05 ether);

        // Withdraw
        vm.prank(guesser);
        game.withdraw();
        vm.prank(guesser2);
        game.withdraw();

        // Verify final balances
        assertEq(guesser.balance, guesser1Start + 0.1 ether); // gained bounty share
        assertEq(guesser2.balance, guesser2Start + 0.05 ether); // gained bounty share
    }

    /**
     * @notice Players claim from multiple puzzles and withdraw combined balance
     *
     * Puzzle 1: Forfeited, guesser gets stake + bounty
     * Puzzle 2: Solved by guesser2, guesser gets stake back
     * Both withdraw their accumulated balances in single call
     */
    function test_ClaimFromMultiplePuzzles_ThenWithdraw() public {
        uint256 guesser1Start = guesser.balance;
        uint256 guesser2Start = guesser2.balance;

        // ========== Puzzle 1: Will be forfeited ==========
        vm.prank(creator);
        uint256 puzzleId1 = game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0.01 ether);

        vm.prank(guesser);
        game.submitGuess{value: 0.01 ether}(puzzleId1, 50);

        vm.prank(guesser2);
        game.submitGuess{value: 0.01 ether}(puzzleId1, 99);

        // ========== Puzzle 2: Will be solved by guesser2 ==========
        vm.prank(creator);
        uint256 puzzleId2 = game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0.01 ether);

        vm.prank(guesser);
        game.submitGuess{value: 0.02 ether}(puzzleId2, 50);

        vm.prank(guesser2);
        game.submitGuess{value: 0.02 ether}(puzzleId2, 42); // correct guess

        // ========== Puzzle 1: Forfeit ==========
        vm.warp(block.timestamp + game.RESPONSE_TIMEOUT() + 1);
        game.forfeitPuzzle(puzzleId1, 0);

        // Both claim from puzzle 1
        vm.prank(guesser);
        game.claimFromForfeited(puzzleId1);
        // guesser: 0.01 stake + 0.05 bounty (0.1/2)

        vm.prank(guesser2);
        game.claimFromForfeited(puzzleId1);
        // guesser2: 0.01 stake + 0.05 bounty (0.1/2)

        // ========== Puzzle 2: Solve ==========
        // Reset time for puzzle 2 responses
        vm.warp(block.timestamp - game.RESPONSE_TIMEOUT());

        // Creator responds to guesser's wrong guess
        vm.prank(creator);
        game.respondToChallenge(
            puzzleId2, 0, validProofA_incorrect, validProofB_incorrect, validProofC_incorrect, validPubSignals_incorrect
        );
        // guesser gets 0.02 stake back immediately

        // Creator responds to guesser2's correct guess - puzzle solved
        vm.prank(creator);
        game.respondToChallenge(
            puzzleId2, 1, validProofA_correct, validProofB_correct, validProofC_correct, validPubSignals_correct
        );
        // guesser2 gets 0.02 stake + 0.2 bounty immediately

        // ========== Check balances before withdraw ==========
        // Guesser: 0.01 + 0.05 from puzzle 1 forfeit claim
        assertEq(game.balances(guesser), 0.06 ether);

        // Guesser2: 0.01 + 0.05 from puzzle 1 forfeit claim
        assertEq(game.balances(guesser2), 0.06 ether);

        // ========== Withdraw ==========
        vm.prank(guesser);
        game.withdraw();

        vm.prank(guesser2);
        game.withdraw();

        // ========== Verify final balances ==========
        // Bounty is 0.1 ether per puzzle (half of 0.2 ether total)
        // Guesser: started, paid 0.01+0.02=0.03 stakes, got back:
        //   - 0.02 immediately from puzzle2 response
        //   - 0.06 from withdraw (puzzle1 claim: 0.01 stake + 0.05 bounty share)
        // Net: +0.05 (bounty share from puzzle1)
        assertEq(guesser.balance, guesser1Start + 0.05 ether);

        // Guesser2: started, paid 0.01+0.02=0.03 stakes, got back:
        //   - 0.02+0.1=0.12 immediately from puzzle2 win (bounty is 0.1 ether)
        //   - 0.06 from withdraw (puzzle1 claim: 0.01 stake + 0.05 bounty share)
        // Net: +0.05 (puzzle1 share) + 0.1 (puzzle2 bounty) = +0.15
        assertEq(guesser2.balance, guesser2Start + 0.15 ether);
    }

    // ============ Additional Coverage Tests ============

    /**
     * @notice Multiple guessers claim stakes from a solved puzzle
     */
    function test_ClaimStakeFromSolved_MultipleGuessers() public {
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0.01 ether);

        uint256 guesser1Start = guesser.balance;
        uint256 guesser2Start = guesser2.balance;

        address guesser3 = makeAddr("guesser3");
        vm.deal(guesser3, 10 ether);
        uint256 guesser3Start = guesser3.balance;

        // Three guessers submit - guesser3 will win
        vm.prank(guesser);
        game.submitGuess{value: 0.01 ether}(puzzleId, 50);

        vm.prank(guesser2);
        game.submitGuess{value: 0.02 ether}(puzzleId, 99);

        vm.prank(guesser3);
        game.submitGuess{value: 0.01 ether}(puzzleId, 42); // correct

        // Creator responds to guesser3's correct guess first - puzzle solved
        vm.prank(creator);
        game.respondToChallenge(
            puzzleId, 2, validProofA_correct, validProofB_correct, validProofC_correct, validPubSignals_correct
        );

        // guesser3 wins bounty + stake immediately
        assertEq(guesser3.balance, guesser3Start + 0.1 ether);

        // Other guessers claim their stakes back
        vm.prank(guesser);
        game.claimStakeFromSolved(puzzleId);

        vm.prank(guesser2);
        game.claimStakeFromSolved(puzzleId);

        assertEq(game.balances(guesser), 0.01 ether);
        assertEq(game.balances(guesser2), 0.02 ether);

        // Withdraw
        vm.prank(guesser);
        game.withdraw();
        vm.prank(guesser2);
        game.withdraw();

        assertEq(guesser.balance, guesser1Start);
        assertEq(guesser2.balance, guesser2Start);
    }

    /**
     * @notice Balance accumulates from both forfeit and solved claims
     */
    function test_BalanceAccumulates_MixedClaimTypes() public {
        uint256 guesserStart = guesser.balance;

        // Puzzle 1: Will be forfeited
        vm.prank(creator);
        uint256 puzzleId1 = game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0.01 ether);

        vm.prank(guesser);
        game.submitGuess{value: 0.01 ether}(puzzleId1, 50);

        // Puzzle 2: Will be solved by someone else
        vm.prank(creator);
        uint256 puzzleId2 = game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0.01 ether);

        vm.prank(guesser);
        game.submitGuess{value: 0.02 ether}(puzzleId2, 50);

        vm.prank(guesser2);
        game.submitGuess{value: 0.01 ether}(puzzleId2, 42); // winner

        // Forfeit puzzle 1
        vm.warp(block.timestamp + game.RESPONSE_TIMEOUT() + 1);
        game.forfeitPuzzle(puzzleId1, 0);

        vm.prank(guesser);
        game.claimFromForfeited(puzzleId1);
        // guesser: 0.01 stake + 0.1 bounty = 0.11

        // Solve puzzle 2
        vm.warp(block.timestamp - game.RESPONSE_TIMEOUT());
        vm.prank(creator);
        game.respondToChallenge(
            puzzleId2, 1, validProofA_correct, validProofB_correct, validProofC_correct, validPubSignals_correct
        );

        // guesser claims stake from solved puzzle
        vm.prank(guesser);
        game.claimStakeFromSolved(puzzleId2);
        // guesser: adds 0.02 stake

        // Combined balance
        assertEq(game.balances(guesser), 0.11 ether + 0.02 ether);

        // Single withdraw gets everything
        vm.prank(guesser);
        game.withdraw();

        // Net: paid 0.03 stakes, got 0.13 back = +0.10 (bounty from puzzle1)
        assertEq(guesser.balance, guesserStart + 0.1 ether);
    }

    /**
     * @notice Withdraw with zero balance reverts
     */
    function test_Withdraw_ZeroBalance() public {
        vm.prank(guesser);
        vm.expectRevert(IGuessGame.NothingToWithdraw.selector);
        game.withdraw();
    }

    /**
     * @notice Second withdraw after first succeeds reverts
     */
    function test_Withdraw_MultipleTimes() public {
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0.01 ether);

        vm.prank(guesser);
        game.submitGuess{value: 0.01 ether}(puzzleId, 50);

        vm.warp(block.timestamp + game.RESPONSE_TIMEOUT() + 1);
        game.forfeitPuzzle(puzzleId, 0);

        vm.prank(guesser);
        game.claimFromForfeited(puzzleId);

        // First withdraw succeeds
        vm.prank(guesser);
        game.withdraw();

        // Second withdraw fails
        vm.prank(guesser);
        vm.expectRevert(IGuessGame.NothingToWithdraw.selector);
        game.withdraw();
    }

    /**
     * @notice Guesser with multiple challenges claims all at once from solved puzzle
     */
    function test_ClaimStakeFromSolved_GuesserWithMultipleChallenges() public {
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0.01 ether);

        uint256 guesserStart = guesser.balance;

        // Guesser submits 3 wrong guesses
        vm.prank(guesser);
        game.submitGuess{value: 0.01 ether}(puzzleId, 50);

        vm.prank(guesser);
        game.submitGuess{value: 0.02 ether}(puzzleId, 99);

        vm.prank(guesser);
        game.submitGuess{value: 0.03 ether}(puzzleId, 77);

        // guesser2 wins
        vm.prank(guesser2);
        game.submitGuess{value: 0.01 ether}(puzzleId, 42);

        vm.prank(creator);
        game.respondToChallenge(
            puzzleId, 3, validProofA_correct, validProofB_correct, validProofC_correct, validPubSignals_correct
        );

        // Guesser claims all 3 stakes in one call
        vm.prank(guesser);
        game.claimStakeFromSolved(puzzleId);

        assertEq(game.balances(guesser), 0.06 ether); // 0.01 + 0.02 + 0.03

        vm.prank(guesser);
        game.withdraw();

        assertEq(guesser.balance, guesserStart); // got all stakes back
    }

    /**
     * @notice Winner's aggregates are zeroed so they cannot claim
     */
    function test_ClaimStakeFromSolved_WinnerCannotClaim() public {
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0.01 ether);

        vm.prank(guesser);
        game.submitGuess{value: 0.01 ether}(puzzleId, 42); // correct

        vm.prank(creator);
        game.respondToChallenge(
            puzzleId, 0, validProofA_correct, validProofB_correct, validProofC_correct, validPubSignals_correct
        );

        // Winner's aggregates are decremented to 0
        assertEq(game.guesserStakeTotal(puzzleId, guesser), 0);
        assertEq(game.guesserChallengeCount(puzzleId, guesser), 0);

        // Winner tries to claim - nothing to claim
        vm.prank(guesser);
        vm.expectRevert(IGuessGame.NothingToClaim.selector);
        game.claimStakeFromSolved(puzzleId);
    }

    /**
     * @notice Verify aggregates decrement correctly after respondToChallenge
     */
    function test_AggregatesDecrementOnResponse() public {
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0.01 ether);

        // Guesser submits 2 guesses
        vm.prank(guesser);
        game.submitGuess{value: 0.01 ether}(puzzleId, 50);

        vm.prank(guesser);
        game.submitGuess{value: 0.02 ether}(puzzleId, 99);

        // Check initial aggregates
        assertEq(game.guesserStakeTotal(puzzleId, guesser), 0.03 ether);
        assertEq(game.guesserChallengeCount(puzzleId, guesser), 2);

        // Respond to first challenge
        vm.prank(creator);
        game.respondToChallenge(
            puzzleId, 0, validProofA_incorrect, validProofB_incorrect, validProofC_incorrect, validPubSignals_incorrect
        );

        // Aggregates decremented
        assertEq(game.guesserStakeTotal(puzzleId, guesser), 0.02 ether);
        assertEq(game.guesserChallengeCount(puzzleId, guesser), 1);

        // Respond to second challenge
        vm.prank(creator);
        game.respondToChallenge(
            puzzleId,
            1,
            validProofA_incorrect_99,
            validProofB_incorrect_99,
            validProofC_incorrect_99,
            validPubSignals_incorrect_99
        );

        // Aggregates now zero
        assertEq(game.guesserStakeTotal(puzzleId, guesser), 0);
        assertEq(game.guesserChallengeCount(puzzleId, guesser), 0);
    }

    /**
     * @notice Cannot claim from unsolved puzzle
     */
    function test_ClaimStakeFromSolved_UnsolvedPuzzle() public {
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0.01 ether);

        vm.prank(guesser);
        game.submitGuess{value: 0.01 ether}(puzzleId, 50);

        vm.prank(guesser);
        vm.expectRevert(IGuessGame.PuzzleNotSolved.selector);
        game.claimStakeFromSolved(puzzleId);
    }

    /**
     * @notice Cannot claim from cancelled puzzle
     */
    function test_ClaimFromCancelledPuzzle() public {
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0.01 ether);

        // Cancel immediately (no challenges)
        vm.prank(creator);
        game.cancelPuzzle(puzzleId);

        // Cannot claim forfeit
        vm.prank(guesser);
        vm.expectRevert(IGuessGame.PuzzleNotForfeited.selector);
        game.claimFromForfeited(puzzleId);

        // Cannot claim solved
        vm.prank(guesser);
        vm.expectRevert(IGuessGame.PuzzleNotSolved.selector);
        game.claimStakeFromSolved(puzzleId);
    }

    /**
     * @notice Balance accumulates from multiple forfeited puzzles
     */
    function test_BalanceAccumulates_MultipleForfeitedPuzzles() public {
        uint256 guesserStart = guesser.balance;

        // Create and forfeit 3 puzzles
        uint256[] memory puzzleIds = new uint256[](3);

        for (uint256 i = 0; i < 3; i++) {
            vm.prank(creator);
            puzzleIds[i] = game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0.01 ether);

            vm.prank(guesser);
            game.submitGuess{value: 0.01 ether}(puzzleIds[i], 50);
        }

        // Forfeit all
        vm.warp(block.timestamp + game.RESPONSE_TIMEOUT() + 1);
        for (uint256 i = 0; i < 3; i++) {
            game.forfeitPuzzle(puzzleIds[i], 0);
        }

        // Claim from all
        for (uint256 i = 0; i < 3; i++) {
            vm.prank(guesser);
            game.claimFromForfeited(puzzleIds[i]);
        }

        // Balance = 3 * (0.01 stake + 0.1 bounty) = 0.33 ether
        assertEq(game.balances(guesser), 0.33 ether);

        // Single withdraw
        vm.prank(guesser);
        game.withdraw();

        // Net gain = 3 * 0.1 bounty = 0.3 ether
        assertEq(guesser.balance, guesserStart + 0.3 ether);
    }

    /**
     * @notice Single guesser on forfeit gets entire bounty
     */
    function test_SingleGuesserForfeit_GetsEntireBounty() public {
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 1 ether}(COMMITMENT_42_123, 0.01 ether);

        uint256 guesserStart = guesser.balance;

        vm.prank(guesser);
        game.submitGuess{value: 0.01 ether}(puzzleId, 50);

        vm.warp(block.timestamp + game.RESPONSE_TIMEOUT() + 1);
        game.forfeitPuzzle(puzzleId, 0);

        vm.prank(guesser);
        game.claimFromForfeited(puzzleId);

        // Gets stake + entire bounty
        assertEq(game.balances(guesser), 0.01 ether + 0.5 ether);

        vm.prank(guesser);
        game.withdraw();

        assertEq(guesser.balance, guesserStart + 0.5 ether);
    }

    /**
     * @notice Forfeit claim works correctly at MIN_STAKE
     */
    function test_MinStake_ForfeitClaim() public {
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0.00001 ether);

        uint256 guesserStart = guesser.balance;

        // Submit at exactly MIN_STAKE
        vm.prank(guesser);
        game.submitGuess{value: 0.00001 ether}(puzzleId, 50);

        vm.warp(block.timestamp + game.RESPONSE_TIMEOUT() + 1);
        game.forfeitPuzzle(puzzleId, 0);

        vm.prank(guesser);
        game.claimFromForfeited(puzzleId);

        // Gets MIN_STAKE + entire bounty
        assertEq(game.balances(guesser), 0.00001 ether + 0.1 ether);

        vm.prank(guesser);
        game.withdraw();

        assertEq(guesser.balance, guesserStart + 0.1 ether);
    }

    // ============ Collateral Tests ============

    /**
     * @notice Verify creator gets collateral back when puzzle is solved (correct guess)
     */
    function test_CorrectGuessReturnsCollateralToCreator() public {
        uint256 creatorStart = creator.balance;

        // Create puzzle with 0.2 ether (0.1 bounty + 0.1 collateral)
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0.01 ether);

        assertEq(creator.balance, creatorStart - 0.2 ether);

        // Submit correct guess
        vm.prank(guesser);
        uint256 challengeId = game.submitGuess{value: 0.01 ether}(puzzleId, 42);

        // Respond with correct proof
        vm.prank(creator);
        game.respondToChallenge(
            puzzleId,
            challengeId,
            validProofA_correct,
            validProofB_correct,
            validProofC_correct,
            validPubSignals_correct
        );

        // Creator's collateral should be credited to internal balance
        assertEq(game.balances(creator), 0.1 ether);

        // Creator withdraws collateral
        vm.prank(creator);
        game.withdraw();

        // Creator now has: original - 0.2 (paid) + 0.1 (collateral) = original - 0.1 (lost bounty only)
        assertEq(creator.balance, creatorStart - 0.1 ether);
    }

    /**
     * @notice Verify duplicate guesses are rejected (basic test with proofs)
     */
    function test_DuplicateGuessRejected() public {
        // Create puzzle
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0.01 ether);

        // First guess succeeds
        vm.prank(guesser);
        game.submitGuess{value: 0.01 ether}(puzzleId, 50);

        // Duplicate guess from different guesser fails
        vm.prank(guesser2);
        vm.expectRevert(IGuessGame.GuessAlreadySubmitted.selector);
        game.submitGuess{value: 0.01 ether}(puzzleId, 50);
    }

    /**
     * @notice Verify collateral is still fully slashed after partial responses
     */
    function test_ForfeitAfterPartialResponses_CollateralStillSlashed() public {
        uint256 treasuryStart = treasury.balance;

        // Create puzzle
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.24 ether}(COMMITMENT_42_123, 0.01 ether);

        // Submit three guesses
        vm.prank(guesser);
        game.submitGuess{value: 0.01 ether}(puzzleId, 50);

        vm.prank(guesser2);
        game.submitGuess{value: 0.01 ether}(puzzleId, 99);

        address guesser3 = makeAddr("guesser3");
        vm.deal(guesser3, 10 ether);
        vm.prank(guesser3);
        game.submitGuess{value: 0.01 ether}(puzzleId, 77);

        // Creator responds to challenge 0 only
        vm.prank(creator);
        game.respondToChallenge(
            puzzleId,
            0,
            validProofA_incorrect,
            validProofB_incorrect,
            validProofC_incorrect,
            validPubSignals_incorrect
        );

        // Warp and forfeit using challenge 1
        vm.warp(block.timestamp + game.RESPONSE_TIMEOUT() + 1);
        game.forfeitPuzzle(puzzleId, 1);

        // Treasury gets FULL collateral (0.12 ether), not partial
        assertEq(treasury.balance, treasuryStart + 0.12 ether);
    }

    /**
     * @notice All incorrect guesses responded - creator keeps collateral on cancel
     */
    function test_AllIncorrectGuesses_NoSlashing() public {
        uint256 treasuryStart = treasury.balance;

        // Create puzzle
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0.01 ether);

        // Submit 2 wrong guesses
        vm.prank(guesser);
        game.submitGuess{value: 0.01 ether}(puzzleId, 50);

        vm.prank(guesser2);
        game.submitGuess{value: 0.01 ether}(puzzleId, 99);

        // Creator responds to both
        vm.prank(creator);
        game.respondToChallenge(
            puzzleId, 0, validProofA_incorrect, validProofB_incorrect, validProofC_incorrect, validPubSignals_incorrect
        );

        vm.prank(creator);
        game.respondToChallenge(
            puzzleId,
            1,
            validProofA_incorrect_99,
            validProofB_incorrect_99,
            validProofC_incorrect_99,
            validPubSignals_incorrect_99
        );

        // Warp past cancel timeout and cancel
        vm.warp(block.timestamp + game.CANCEL_TIMEOUT() + 1);

        uint256 creatorBalanceBefore = creator.balance;

        vm.prank(creator);
        game.cancelPuzzle(puzzleId);

        // Creator gets bounty + collateral back
        assertEq(creator.balance, creatorBalanceBefore + 0.2 ether);

        // Treasury unchanged - no slashing
        assertEq(treasury.balance, treasuryStart);
    }

    /**
     * @notice Verify collateral is slashed to treasury on forfeit
     */
    function test_ForfeitSlashesCollateral() public {
        uint256 treasuryStart = treasury.balance;

        // Create puzzle
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.2 ether}(COMMITMENT_42_123, 0.01 ether);

        // Submit guess
        vm.prank(guesser);
        uint256 challengeId = game.submitGuess{value: 0.01 ether}(puzzleId, 50);

        // Warp and forfeit
        vm.warp(block.timestamp + game.RESPONSE_TIMEOUT() + 1);
        game.forfeitPuzzle(puzzleId, challengeId);

        // Treasury receives collateral
        assertEq(treasury.balance, treasuryStart + 0.1 ether);

        // Guesser can still claim bounty share
        vm.prank(guesser);
        game.claimFromForfeited(puzzleId);
        assertEq(game.balances(guesser), 0.01 ether + 0.1 ether); // stake + entire bounty
    }
}

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.30;

import "forge-std/Test.sol";
import "../src/GuessGame.sol";
import "../src/generated/GuessVerifier.sol";

contract GuessGameWithProofsTest is Test {
    Groth16Verifier public verifier;
    GuessGame public game;
    
    address creator;
    address guesser;
    address guesser2;
    
    // Test data with VALID ZK proofs generated by the actual circuit
    // For number=42, salt=123
    bytes32 constant COMMITMENT_42_123 = 0x1d869fb8246b6131377493aaaf1cc16a8284d4aedcb7277079df35d0d1d552d1;
    
    // Valid proof for correct guess (42)
    uint[2] validProofA_correct = [
        20733104445222474913460899055922638733390515415268774731643134142498872084191,
        14000468808382636465462761302394038173719213862863751644422554851223456811411
    ];
    uint[2][2] validProofB_correct = [
        [14529324359401080920218683234881556919213052277135946418796017114639319774385,
         12129083737057255635218975576710777788141717515839459178762095078342656790038],
        [4006130398494418696741732007622629431845312574338850368957129174821663088541,
         5320382245369139568202711526684359871618209808068963385672210545364024687600]
    ];
    uint[2] validProofC_correct = [
        11555678601106434654959630063997038302724273931564919993607610338934924583422,
        12395595758571672800576038452878068084738676055843400774526791354550122500902
    ];
    uint[3] validPubSignals_correct = [
        uint256(13354932457729771147254927911602504548850183657014898888488396374653942452945),
        1, // isCorrect = true
        42 //guess
    ];
    
    // Valid proof for incorrect guess (50)
    uint[2] validProofA_incorrect = [
        260224852269514550962255596791713148069192103530930225168509498623216740997,
        3464936673232863366747749560095954607406672448198506930195439109614243395305
    ];
    uint[2][2] validProofB_incorrect = [
        [18076787037990225159899307248733301104058781270403724423075272532649526747523,
         21163582130445499238873337568384386692136208661991064222861763232945956209076],
        [14700551543044113104786011479044690264965500866720142037325671448170897252180,
         248536395010580566114959855988956594661021088223112251086687402479116093507]
    ];
    uint[2] validProofC_incorrect = [
        3718774677296111965628987936986701738438916711731522663485615268638604855259,
        15664470303899517099778638779831003600948012776255763324223926677414563225933
    ];
    uint[3] validPubSignals_incorrect = [
        uint256(13354932457729771147254927911602504548850183657014898888488396374653942452945),
        0, // isCorrect = false
        50 //guess
    ];
    
    uint[2] validProofA_incorrect_99 = [
        1522250115459347886732366836753121648149166765464232477792700654355908098958,
        12230247335391372868598697888961446586952358073485687489866514136177234102516
    ];
    uint[2][2] validProofB_incorrect_99 = [
        [829808490343623106010157378861222277376158829827485398099043639305686191932,
         17794992986969421673750416099231395431613517939633365877256108996901124885408],
        [13764104074731906666379119009729886488089352881221577140560629738823728313757,
         8228639052365462362835629439297935566254125449786065112616179334330818224187]
    ];
    uint[2] validProofC_incorrect_99 = [
        1477156412658329873137803094926985163386885774473985262711014984933715457935,
        13394207920715449173518714206562449218544155651180071706369101076169486617299
    ];
    uint[3] validPubSignals_incorrect_99 = [
        uint256(13354932457729771147254927911602504548850183657014898888488396374653942452945),
        0, // isCorrect = false
        99 //guess
    ];

    function setUp() public {
        // Create test addresses that can receive ETH
        creator = makeAddr("creator");
        guesser = makeAddr("guesser");
        guesser2 = makeAddr("guesser2");
        
        // Deploy verifier first
        verifier = new Groth16Verifier();
        // Deploy game with verifier address
        game = new GuessGame(address(verifier));
        
        vm.deal(creator, 10 ether);
        vm.deal(guesser, 10 ether);
        vm.deal(guesser2, 10 ether);
    }
    
    function test_RespondToChallenge_CorrectGuess_WithValidProof() public {
        // Create puzzle
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.1 ether}(
            COMMITMENT_42_123,
            0.01 ether,
            50
        );
        
        // Submit correct guess
        vm.prank(guesser);
        uint256 challengeId = game.submitGuess{value: 0.01 ether}(puzzleId, 42);
        
        // Check initial state
        IGuessGame.Puzzle memory puzzleBefore = game.getPuzzle(puzzleId);
        assertEq(puzzleBefore.totalStaked, 0.01 ether);
        assertEq(puzzleBefore.solved, false);
        
        uint256 guesserBalanceBefore = guesser.balance;
        
        // Respond with valid proof showing guess is correct
        vm.prank(creator);
        game.respondToChallenge(
            challengeId,
            validProofA_correct,
            validProofB_correct,
            validProofC_correct,
            validPubSignals_correct
        );
        
        // Verify puzzle is solved
        IGuessGame.Puzzle memory puzzleAfter = game.getPuzzle(puzzleId);
        assertEq(puzzleAfter.solved, true);
        
        // Verify challenge is marked as responded
        IGuessGame.Challenge memory challenge = game.getChallenge(challengeId);
        assertEq(challenge.responded, true);
        
        // Verify winner received bounty + stake
        uint256 expectedPrize = 0.1 ether + 0.01 ether; // bounty + stake (no creator reward)
        assertEq(guesser.balance, guesserBalanceBefore + expectedPrize);
    }
    
    function test_RespondToChallenge_IncorrectGuess_WithValidProof() public {
        // Create puzzle
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.1 ether}(
            COMMITMENT_42_123,
            0.01 ether,
            50 // 50% growth
        );
        
        // Submit incorrect guess
        vm.prank(guesser);
        uint256 challengeId = game.submitGuess{value: 0.01 ether}(puzzleId, 50);
        
        // Check initial state
        IGuessGame.Puzzle memory puzzleBefore = game.getPuzzle(puzzleId);
        uint256 bountyBefore = puzzleBefore.bounty;
        
        uint256 creatorBalanceBefore = creator.balance;
        
        // Respond with valid proof showing guess is incorrect
        vm.prank(creator);
        game.respondToChallenge(
            challengeId,
            validProofA_incorrect,
            validProofB_incorrect,
            validProofC_incorrect,
            validPubSignals_incorrect
        );
        
        // Verify puzzle is NOT solved
        IGuessGame.Puzzle memory puzzleAfter = game.getPuzzle(puzzleId);
        assertEq(puzzleAfter.solved, false);
        
        // Verify bounty increased by 50% of stake (50% growth rate)
        assertEq(puzzleAfter.bounty, bountyBefore + 0.005 ether);
        
        // Verify creator reward is accumulated in puzzle (not transferred yet)
        assertEq(puzzleAfter.creatorReward, 0.005 ether);
        // Creator balance should remain unchanged
        assertEq(creator.balance, creatorBalanceBefore);
    }
    
    function test_RespondToChallenge_MultipleGuesses_ThenCorrect() public {
        // Create puzzle
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.1 ether}(
            COMMITMENT_42_123,
            0.01 ether,
            50
        );
        
        // First incorrect guess
        vm.prank(guesser);
        uint256 challengeId1 = game.submitGuess{value: 0.01 ether}(puzzleId, 50);
        
        // Respond to first guess (incorrect)
        vm.prank(creator);
        game.respondToChallenge(
            challengeId1,
            validProofA_incorrect,
            validProofB_incorrect,
            validProofC_incorrect,
            validPubSignals_incorrect
        );
        
        // Second incorrect guess from different guesser
        vm.prank(guesser2);
        uint256 challengeId2 = game.submitGuess{value: 0.01 ether}(puzzleId, 99);

        vm.prank(creator);
        game.respondToChallenge(
            challengeId2,
            validProofA_incorrect_99,
            validProofB_incorrect_99,
            validProofC_incorrect_99,
            validPubSignals_incorrect_99
        );
        
        IGuessGame.Puzzle memory puzzleAfterIncorrect = game.getPuzzle(puzzleId);
        assertEq(puzzleAfterIncorrect.bounty, 0.1 ether + 0.005 ether + 0.005 ether);
        assertEq(puzzleAfterIncorrect.totalStaked, 0.02 ether);
        assertEq(puzzleAfterIncorrect.creatorReward, 0.005 ether + 0.005 ether);
        
        // Log state after incorrect guesses
        console.log("After incorrect guesses:");
        console.log("  Bounty:", puzzleAfterIncorrect.bounty);
        console.log("  Total staked:", puzzleAfterIncorrect.totalStaked);
        console.log("  Creator reward:", puzzleAfterIncorrect.creatorReward);
        
        // Now submit correct guess
        uint256 guesserBalanceBefore = guesser.balance;
        vm.prank(guesser);
        uint256 challengeId3 = game.submitGuess{value: 0.01 ether}(puzzleId, 42);
        
        // Check contract balance before final response
        uint256 contractBalance = address(game).balance;
        assertEq(contractBalance, 0.13 ether); // 0.1 initial + 0.03 from stakes
        
        // Check expected payouts
        IGuessGame.Puzzle memory puzzleBeforeSolve = game.getPuzzle(puzzleId);
        uint256 expectedWinnerPrize = puzzleBeforeSolve.bounty + puzzleBeforeSolve.totalStaked - puzzleBeforeSolve.creatorReward;
        uint256 expectedCreatorPayout = puzzleBeforeSolve.creatorReward;
        
        // Log values for debugging
        console.log("Before solving:");
        console.log("  Puzzle bounty:", puzzleBeforeSolve.bounty);
        console.log("  Total staked:", puzzleBeforeSolve.totalStaked);
        console.log("  Creator reward:", puzzleBeforeSolve.creatorReward);
        console.log("Contract balance:", contractBalance);
        console.log("Expected winner prize:", expectedWinnerPrize);
        console.log("Expected creator payout:", expectedCreatorPayout);
        console.log("Total needed:", expectedWinnerPrize + expectedCreatorPayout);
        
        // Respond with correct proof
        vm.prank(creator);
        game.respondToChallenge(
            challengeId3,
            validProofA_correct,
            validProofB_correct,
            validProofC_correct,
            validPubSignals_correct
        );
        
        // Verify puzzle is solved
        IGuessGame.Puzzle memory puzzleFinal = game.getPuzzle(puzzleId);
        assertEq(puzzleFinal.solved, true);
        
        assertEq(guesser.balance, guesserBalanceBefore - 0.01 ether + expectedWinnerPrize);
    }
    
    function test_RespondToChallenge_InvalidCommitment_Reverts() public {
        // Create puzzle
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.1 ether}(
            COMMITMENT_42_123,
            0.01 ether,
            50
        );
        
        vm.prank(guesser);
        uint256 challengeId = game.submitGuess{value: 0.01 ether}(puzzleId, 42);
        
        // Create proof with wrong commitment
        uint[3] memory wrongPubSignals = [
            uint256(0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef), // wrong commitment
            1,
            42
        ];
        
        vm.prank(creator);
        vm.expectRevert(IGuessGame.InvalidProof.selector);
        game.respondToChallenge(
            challengeId,
            validProofA_correct,
            validProofB_correct,
            validProofC_correct,
            wrongPubSignals
        );
    }
    
    function test_RespondToChallenge_AlreadyResponded_Reverts() public {
        // Create puzzle and submit guess
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.1 ether}(
            COMMITMENT_42_123,
            0.01 ether,
            50
        );
        
        vm.prank(guesser);
        uint256 challengeId = game.submitGuess{value: 0.01 ether}(puzzleId, 50);
        
        // First response
        vm.prank(creator);
        game.respondToChallenge(
            challengeId,
            validProofA_incorrect,
            validProofB_incorrect,
            validProofC_incorrect,
            validPubSignals_incorrect
        );
        
        // Try to respond again
        vm.prank(creator);
        vm.expectRevert(IGuessGame.ChallengeAlreadyResponded.selector);
        game.respondToChallenge(
            challengeId,
            validProofA_incorrect,
            validProofB_incorrect,
            validProofC_incorrect,
            validPubSignals_incorrect
        );
    }
    
    function test_RespondToChallenge_PuzzleAlreadySolved_Reverts() public {
        // Create puzzle
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.1 ether}(
            COMMITMENT_42_123,
            0.01 ether,
            50
        );
        
        // First guess (correct)
        vm.prank(guesser);
        uint256 challengeId1 = game.submitGuess{value: 0.01 ether}(puzzleId, 42);
        
        // Second guess
        vm.prank(guesser2);
        uint256 challengeId2 = game.submitGuess{value: 0.01 ether}(puzzleId, 50);
        
        // Solve puzzle with first guess
        vm.prank(creator);
        game.respondToChallenge(
            challengeId1,
            validProofA_correct,
            validProofB_correct,
            validProofC_correct,
            validPubSignals_correct
        );
        
        // Try to respond to second guess after puzzle is solved
        vm.prank(creator);
        vm.expectRevert(IGuessGame.PuzzleAlreadySolved.selector);
        game.respondToChallenge(
            challengeId2,
            validProofA_incorrect,
            validProofB_incorrect,
            validProofC_incorrect,
            validPubSignals_incorrect
        );
    }

    function test_RespondToChallenge_InvalidProofForChallengeGuess() public {
        vm.prank(creator);
        uint256 puzzleId = game.createPuzzle{value: 0.1 ether}(
            COMMITMENT_42_123,
            0.01 ether,
            50
        );

        vm.prank(guesser);
        uint256 challengeId = game.submitGuess{value: 0.01 ether}(puzzleId, 11);

        vm.prank(guesser);
        uint256 challengeId1 = game.submitGuess{value: 0.01 ether}(puzzleId, 42);

        vm.prank(creator);
        vm.expectRevert(IGuessGame.InvalidProofForChallengeGuess.selector);
        game.respondToChallenge(
            challengeId,
            validProofA_correct,
            validProofB_correct,
            validProofC_correct,
            validPubSignals_correct
        );

        vm.prank(creator);
        vm.expectRevert(IGuessGame.InvalidProofForChallengeGuess.selector);
        game.respondToChallenge(
            challengeId1,
            validProofA_incorrect_99,
            validProofB_incorrect_99,
            validProofC_incorrect_99,
            validPubSignals_incorrect_99
        );
    }
}
